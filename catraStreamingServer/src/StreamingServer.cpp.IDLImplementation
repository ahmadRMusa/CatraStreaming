/*
 Copyright (C) Giuliano Catrambone (giuliano.catrambone@catrasoftware.it)

 This program is free software; you can redistribute it and/or 
 modify it under the terms of the GNU General Public License 
 as published by the Free Software Foundation; either 
 version 2 of the License, or (at your option) any later 
 version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

 Commercial use other than under the terms of the GNU General Public
 License is allowed only after express negotiation of conditions
 with the authors.
*/


#ifdef WIN32
#else
	#include "CatraStreaming_OSConfig.h"
#endif
#include "StreamingServer.h"
#include "StreamingServerMessages.h"
#include "ServerSocket.h"
#include "ClientSocket.h"
#include "FileIO.h"
#include "System.h"
#include <stdlib.h>
#include <assert.h>
#ifdef WIN32
	#include <Winsock2.h>
	#include <direct.h>
#else
	#include <netdb.h>
	#include <sys/socket.h>
	#include <netinet/in.h>
	#include <arpa/inet.h>
	#include <sys/utsname.h>
	#include <unistd.h>
	#include <dirent.h>
#endif
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#ifdef HAVE_CORBA_H
	#include "coss/CosNaming.h"
#endif
#include "GetCpuUsage.h"


#ifdef HAVE_CORBA_H
	StreamingServer:: StreamingServer (void):
		POA_StreamingIDL:: StreamingServer ()
#else
	StreamingServer:: StreamingServer (void)
#endif

{

}


StreamingServer:: ~StreamingServer (void)

{

}


Error StreamingServer:: init (
	int iArgc, char **pArgv,
	ConfigurationFile_p pcfConfiguration,
	Tracer_p ptSystemTracer, Tracer_p ptSubscriberTracer)

{

	char					pConfigurationBuffer [SS_MAXLONGLENGTH];
	Error_t					errGetItemValue;
	unsigned long			ulMaxLiveSourcesNumber;


	_pcfConfiguration					= pcfConfiguration;
	_ptSystemTracer						= ptSystemTracer;
	_ptSubscriberTracer					= ptSubscriberTracer;

	#ifdef HAVE_CORBA_H
		// ORB initialization
		_porb = CORBA::ORB_init (iArgc, pArgv);

		// POA initialization
		CORBA::Object_var poaobj =
			_porb -> resolve_initial_references ("RootPOA");
		_poa = PortableServer::POA::_narrow (poaobj);
		_pmgr = _poa -> the_POAManager();
	#endif

	if (System:: getHostName (_pHostName, SS_MAXHOSTNAMELENGTH) != errNoError)
	{
		Error err = ToolsErrors (__FILE__, __LINE__,
			TOOLS_SYSTEM_GETHOSTNAME_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		return err;
	}

	if ((errGetItemValue = _pcfConfiguration -> getItemValue ("StreamingServer",
		"Standard", pConfigurationBuffer,
		SS_MAXLONGLENGTH)) != errNoError)
	{
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) errGetItemValue,
			__FILE__, __LINE__);

		Error err = ConfigurationErrors (__FILE__, __LINE__,
			CFG_CONFIG_GETITEMVALUE_FAILED,
			2, "StreamingServer", "Standard");
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		return err;
	}

	if (!strcmp (pConfigurationBuffer, "ISMA"))
		_sStandard			= MP4Atom:: MP4F_ISMA;
	else if (!strcmp (pConfigurationBuffer, "3GPP"))
		_sStandard			= MP4Atom:: MP4F_3GPP;
	else
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_CONFIGITEMWRONG,
			2, "StreamingServer", "Standard");
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		return err;
	}

	// mp4fMP4FileFactory initialization
	{
		unsigned long			ulMaxMp4FilesNumberInMemory;
		unsigned long			ulMp4FilesNumberToDeleteOnOverflow;
		Boolean_t				bUseMP4ConsistencyCheck;
		unsigned long			ulBucketsNumberForMP4FilesCache;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Cache",
			"MaxMp4FilesNumberInMemory", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Cache", "MaxMp4FilesNumberInMemory");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		ulMaxMp4FilesNumberInMemory			= 
			strtoul (pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Cache",
			"Mp4FilesNumberToDeleteOnOverflow",
			pConfigurationBuffer, SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Cache", "MaxMp4FilesNumberInMemory");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		ulMp4FilesNumberToDeleteOnOverflow				=
			strtoul (pConfigurationBuffer, (char **) NULL, 10);

		if (ulMp4FilesNumberToDeleteOnOverflow >
			ulMaxMp4FilesNumberInMemory)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CONFIGITEMWRONG,
2, "Cache", "MaxMp4FilesNumberInMemory or Mp4FilesNumberToDeleteOnOverflow");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Cache",
			"UseMP4ConsistencyCheck", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Cache", "UseMP4ConsistencyCheck");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		if (!strcmp (pConfigurationBuffer, "true"))
			bUseMP4ConsistencyCheck			= true;
		else
			bUseMP4ConsistencyCheck			= false;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Cache",
			"BucketsNumberForMP4FilesCache",
			pConfigurationBuffer, SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Cache", "BucketsNumberForMP4FilesCache");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		ulBucketsNumberForMP4FilesCache				=
			strtoul (pConfigurationBuffer, (char **) NULL, 10);

		if (_mp4fMP4FileFactory. init (ulMaxMp4FilesNumberInMemory,
			ulMp4FilesNumberToDeleteOnOverflow, bUseMP4ConsistencyCheck,
			_ptSystemTracer, ulBucketsNumberForMP4FilesCache) != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
	}

	if ((errGetItemValue = _pcfConfiguration -> getItemValue ("StreamingServer",
		"MaxRTSPSessions", pConfigurationBuffer,
		SS_MAXLONGLENGTH)) != errNoError)
	{
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) errGetItemValue,
			__FILE__, __LINE__);

		Error err = ConfigurationErrors (__FILE__, __LINE__,
			CFG_CONFIG_GETITEMVALUE_FAILED,
			2, "StreamingServer", "MaxRTSPSessions");
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}
	_ulMaxRTSPServerSessions			= strtoul (pConfigurationBuffer,
		(char **) NULL, 10);

	if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
		"MaxLiveSourcesNumber", pConfigurationBuffer,
		SS_MAXLONGLENGTH)) != errNoError)
	{
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) errGetItemValue,
			__FILE__, __LINE__);

		Error err = ConfigurationErrors (__FILE__, __LINE__,
			CFG_CONFIG_GETITEMVALUE_FAILED,
			2, "System", "MaxLiveSourcesNumber");
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}
	ulMaxLiveSourcesNumber		= strtoul (pConfigurationBuffer,
		(char **) NULL, 10);

	{
		if ((_plsLiveSources = new LiveSource_t [ulMaxLiveSourcesNumber]) ==
			(LiveSource_p) NULL)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_NEW_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
	}

	{
		long			lStreamingServerProcessorsNumber;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"StreamingServerProcessorsNumber", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "StreamingServerProcessorsNumber");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		lStreamingServerProcessorsNumber			=
			atol (pConfigurationBuffer);
		if (lStreamingServerProcessorsNumber <= 0)
			// da calcolare secondo il n.ro dei processori della macchina
			_ulStreamingServerProcessorsNumber		= 1;
		else
			_ulStreamingServerProcessorsNumber		=
				lStreamingServerProcessorsNumber;
	}

	if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Scheduler",
		"SchedulerSleepTimeInMilliSecs", pConfigurationBuffer,
		SS_MAXLONGLENGTH)) != errNoError)
	{
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) errGetItemValue,
			__FILE__, __LINE__);

		Error err = ConfigurationErrors (__FILE__, __LINE__,
			CFG_CONFIG_GETITEMVALUE_FAILED,
			2, "Scheduler", "SchedulerSleepTimeInMilliSecs");
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}
	_ulSchedulerSleepTimeInMilliSecs		= strtoul (pConfigurationBuffer,
		(char **) NULL, 10);

	if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Scheduler",
		"CheckServerSocketPeriodInMilliSecs", pConfigurationBuffer,
		SS_MAXLONGLENGTH)) != errNoError)
	{
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) errGetItemValue,
			__FILE__, __LINE__);

		Error err = ConfigurationErrors (__FILE__, __LINE__,
			CFG_CONFIG_GETITEMVALUE_FAILED,
			2, "Scheduler", "CheckServerSocketPeriodInMilliSecs");
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}
	_ulCheckServerSocketPeriodInMilliSecs		= strtoul (pConfigurationBuffer,
		(char **) NULL, 10);

	if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Scheduler",
		"CheckSocketsPoolPeriodInMilliSecs", pConfigurationBuffer,
		SS_MAXLONGLENGTH)) != errNoError)
	{
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) errGetItemValue,
			__FILE__, __LINE__);

		Error err = ConfigurationErrors (__FILE__, __LINE__,
			CFG_CONFIG_GETITEMVALUE_FAILED,
			2, "Scheduler", "CheckSocketsPoolPeriodInMilliSecs");
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}
	_ulCheckSocketsPoolPeriodInMilliSecs		= strtoul (pConfigurationBuffer,
		(char **) NULL, 10);

	_vFreeRTSPSessions. reserve (_ulMaxRTSPServerSessions);


	// EventsSet
	{
		if (_esEventsSet. init (
			StreamingServerEventsSet:: SS_EVENTTYPENUMBER,
			_ptSystemTracer) != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
	}

	// SocketsPool
	if (_spStreamingServerSocketsPool. init (&_esEventsSet,
		_ptSystemTracer) != errNoError)
	{
		Error err = SocketErrors (__FILE__, __LINE__,
			SCK_SOCKETSPOOL_INIT_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}

	if (_mtLiveSources. init (
		PMutex:: MUTEX_RECURSIVE) != errNoError)
	{
		Error err = PThreadErrors (__FILE__, __LINE__,
			THREADLIB_PMUTEX_INIT_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		if (_spStreamingServerSocketsPool. finish () !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETSPOOL_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}

	// initialization of the RTSP sessions (prsRTSPSessions)
	{
		char					pLocalIPAddressForRTP [
			SCK_MAXIPADDRESSLENGTH];
		unsigned long			ulRTP_RTCPStartingPort;
		unsigned long			ulRTP_RTCPReservedPorts;
		unsigned long			ulRTSP_RTCPTimeoutInSecs;
		unsigned long			ulPauseTimeoutInSecs;
		unsigned long			ulSendRTCPPacketsPeriodInMilliSecs;
		unsigned long			ulReceiveRTCPPacketsPeriodInMilliSecs;
		unsigned long			ulSendRTPMaxSleepTimeInMilliSecs;
		unsigned long			ulRTPPacketsNumberToPrefetch;
		unsigned long			ulSamplesNumberToPrefetch;
		char					pLocalIPAddressForRTCP [
			SCK_MAXIPADDRESSLENGTH];
		double					dMaxSpeedAllowed;
		unsigned long			ulPlayDelayTimeInMilliSeconds;
		Boolean_t				bIsOverBufferEnabled;
		unsigned long			ulSendingInterval;
		unsigned long			ulInitialWindowSizeInBytes;
		unsigned long			ulMaxSendAheadTimeInSec;
		float					fOverbufferRate;
		unsigned long			ulLocalRTP_RTCPStartingPort;
		unsigned long			ulMaxPayloadSizeInBytes;
		long					lRTSPSessionIndex;
		Boolean_t				bUseOfHintingTrackIfExist;
		Boolean_t				bBuildOfHintingTrackIfNotExist;
		char					pRequestLogFormat [
			SS_MAXREQUESTLOGFORMATLENGTH];
		Boolean_t				bFlushTraceAfterEachRequest;
		Boolean_t				bAuthorizationActivated;
		char					pAuthorizationServletPathName [
			SS_MAXSERVLETPATHNAMELENGTH];
		char					pAuthorizationWebServerIpAddress [
			SCK_MAXIPADDRESSLENGTH];
		unsigned long			ulAuthorizationWebServerPort;
		char					pAuthorizationLocalIPAddressForHTTP [
			SCK_MAXIPADDRESSLENGTH];
		unsigned long			ulAuthorizationHTTPRequestTimeoutInSecs;
		Boolean_t				bCommitActivated;
		char					pCommitServletPathName [
			SS_MAXSERVLETPATHNAMELENGTH];
		char					pCommitWebServerIpAddress [
			SCK_MAXIPADDRESSLENGTH];
		unsigned long			ulCommitWebServerPort;
		char					pCommitLocalIPAddressForHTTP [
			SCK_MAXIPADDRESSLENGTH];
		unsigned long			ulCommitHTTPRequestTimeoutInSecs;


		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"IPConfiguration",
			"LocalIPAddressForRTP", pLocalIPAddressForRTP,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "IPConfiguration", "LocalIPAddressForRTP");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"IPConfiguration",
			"RTP_RTCPStartingPort", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "IPConfiguration", "RTP_RTCPStartingPort");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulRTP_RTCPStartingPort				= strtoul (pConfigurationBuffer,
			(char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"IPConfiguration",
			"RTP_RTCPReservedPorts", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "IPConfiguration", "RTP_RTCPReservedPorts");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulRTP_RTCPReservedPorts			= strtoul (pConfigurationBuffer,
			(char **) NULL, 10);

		// check that there are enough sockets ports to handle
		//	the _ulMaxRTSPServerSessions number of RTSPSessions
		if (ulRTP_RTCPReservedPorts < _ulMaxRTSPServerSessions * 4)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_RTCPRESERVEDPORTSNOTSUFFICIENT,
				2, ulRTP_RTCPReservedPorts, _ulMaxRTSPServerSessions);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Scheduler",
			"RTSP_RTCPTimeout", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Scheduler", "RTSP_RTCPTimeout");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulRTSP_RTCPTimeoutInSecs			= strtoul (pConfigurationBuffer,
			(char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Scheduler",
			"PauseTimeout", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Scheduler", "PauseTimeout");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulPauseTimeoutInSecs		= strtoul (
			pConfigurationBuffer, (char **) NULL, 10);

		if (ulPauseTimeoutInSecs < ulRTSP_RTCPTimeoutInSecs)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CONFIGITEMWRONG,
				2, "Scheduler", "PauseTimeout or RTSP_RTCPTimeout");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Scheduler",
			"SendRTCPPacketsPeriodInMilliSecs",
			pConfigurationBuffer, SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Scheduler", "SendRTCPPacketsPeriodInMilliSecs");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulSendRTCPPacketsPeriodInMilliSecs		=
			strtoul (pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Scheduler",
			"ReceiveRTCPPacketsPeriodInMilliSecs",
			pConfigurationBuffer, SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Scheduler", "ReceiveRTCPPacketsPeriodInMilliSecs");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulReceiveRTCPPacketsPeriodInMilliSecs		=
			strtoul (pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"SendRTPMaxSleepTimeInMilliSecs",
			pConfigurationBuffer, SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "SendRTPMaxSleepTimeInMilliSecs");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulSendRTPMaxSleepTimeInMilliSecs		=
			strtoul (pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"IPConfiguration",
			"LocalIPAddressForRTSP", _pLocalIPAddressForRTSP,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "IPConfiguration", "LocalIPAddressForRTSP");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"IPConfiguration",
			"LocalIPAddressForRTCP", pLocalIPAddressForRTCP,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "IPConfiguration", "LocalIPAddressForRTCP");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"StreamingServer",
			"RTSPRequestsPort", pConfigurationBuffer, SS_MAXLONGLENGTH)) !=
			errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "StreamingServer", "RTSPRequestsPort");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		_ulRTSPRequestsPort			=
			(unsigned long) atol (pConfigurationBuffer);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"MaxSpeedAllowed", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "MaxSpeedAllowed");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		dMaxSpeedAllowed				= atof (pConfigurationBuffer);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"PlayDelayTimeInMilliSeconds", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "PlayDelayTimeInMilliSeconds");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulPlayDelayTimeInMilliSeconds		= strtoul (
			pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"IsOverBufferEnabled", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "IsOverBufferEnabled");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		if (!strcmp (pConfigurationBuffer, "true"))
			bIsOverBufferEnabled			= true;
		else
			bIsOverBufferEnabled			= false;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"SendingInterval", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "SendingInterval");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulSendingInterval		= strtoul (pConfigurationBuffer,
			(char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"InitialWindowSizeInBytes", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "InitialWindowSizeInBytes");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulInitialWindowSizeInBytes		= strtoul (pConfigurationBuffer,
			(char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"MaxSendAheadTimeInSec", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "MaxSendAheadTimeInSec");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulMaxSendAheadTimeInSec		= strtoul (pConfigurationBuffer,
			(char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"OverbufferRate", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "OverbufferRate");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		fOverbufferRate		= atof (pConfigurationBuffer);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"StreamingServer",
			"ContentRootPath", _pContentRootPath,
			SS_MAXCONTENTROOTPATHLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "StreamingServer", "ContentRootPath");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"MaxPayloadSizeInBytes", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "MaxPayloadSizeInBytes");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulMaxPayloadSizeInBytes			= strtoul (
			pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Cache",
			"FileCacheSizeInBytes", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Cache", "FileCacheSizeInBytes");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		_ulFileCacheSizeInBytes			= strtoul (
			pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"RTPPacketsNumberToPrefetch", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "RTPPacketsNumberToPrefetch");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulRTPPacketsNumberToPrefetch			= strtoul (
			pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"SamplesNumberToPrefetch", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "SamplesNumberToPrefetch");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulSamplesNumberToPrefetch			= strtoul (
			pConfigurationBuffer, (char **) NULL, 10);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"UseOfHintingTrackIfExist", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "UseOfHintingTrackIfExist");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		if (!strcmp (pConfigurationBuffer, "true"))
			bUseOfHintingTrackIfExist			= true;
		else
			bUseOfHintingTrackIfExist			= false;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("System",
			"BuildOfHintingTrackIfNotExist", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "System", "UseOfHintingTrackIfExist");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		if (!strcmp (pConfigurationBuffer, "true"))
			bBuildOfHintingTrackIfNotExist			= true;
		else
			bBuildOfHintingTrackIfNotExist			= false;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"SubscriberLogs",
			"RequestLogFormat", pRequestLogFormat,
			SS_MAXREQUESTLOGFORMATLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "SubscriberLogs", "RequestLogFormat");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"SubscriberLogs",
			"FlushTraceAfterEachRequest", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "SubscriberLogs", "FlushTraceAfterEachRequest");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		if (!strcmp (pConfigurationBuffer, "true"))
			bFlushTraceAfterEachRequest			= true;
		else
			bFlushTraceAfterEachRequest			= false;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"Authorization",
			"Activated", pConfigurationBuffer, SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Authorization", "Activated");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		if (!strcmp (pConfigurationBuffer, "true"))
			bAuthorizationActivated			= true;
		else
			bAuthorizationActivated			= false;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"Authorization",
			"Servlet", pAuthorizationServletPathName,
			SS_MAXSERVLETPATHNAMELENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Authorization", "Servlet");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"Authorization",
			"LocalIPAddressForHTTP", pAuthorizationLocalIPAddressForHTTP,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Authorization", "LocalIPAddressForHTTP");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"Authorization",
			"WebServerIPAddress", pAuthorizationWebServerIpAddress,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Authorization", "WebServerIPAddress");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"Authorization",
			"WebServerPort", pConfigurationBuffer, SS_MAXLONGLENGTH)) !=
			errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Authorization", "WebServerPort");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulAuthorizationWebServerPort			=
			(unsigned long) atol (pConfigurationBuffer);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"Authorization",
			"HTTPRequestTimeoutInSecs", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Authorization", "HTTPRequestTimeoutInSecs");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulAuthorizationHTTPRequestTimeoutInSecs			=
			(unsigned long) atol (pConfigurationBuffer);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Commit",
			"Activated", pConfigurationBuffer, SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Commit", "Activated");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		if (!strcmp (pConfigurationBuffer, "true"))
			bCommitActivated			= true;
		else
			bCommitActivated			= false;

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Commit",
			"Servlet", pCommitServletPathName, SS_MAXSERVLETPATHNAMELENGTH)) !=
			errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Commit", "Servlet");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Commit",
			"LocalIPAddressForHTTP", pCommitLocalIPAddressForHTTP,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Commit", "LocalIPAddressForHTTP");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Commit",
			"WebServerIPAddress", pCommitWebServerIpAddress,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Commit", "WebServerIPAddress");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Commit",
			"WebServerPort", pConfigurationBuffer, SS_MAXLONGLENGTH)) !=
			errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Commit", "WebServerPort");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulCommitWebServerPort			=
			(unsigned long) atol (pConfigurationBuffer);

		if ((errGetItemValue = _pcfConfiguration -> getItemValue ("Commit",
			"HTTPRequestTimeoutInSecs", pConfigurationBuffer,
			SS_MAXLONGLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "Commit", "HTTPRequestTimeoutInSecs");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		ulCommitHTTPRequestTimeoutInSecs			=
			(unsigned long) atol (pConfigurationBuffer);

		if ((_prsRTSPSessions = new RTSPSession_t [
			_ulMaxRTSPServerSessions]) == (RTSPSession_p) NULL)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_NEW_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		ulLocalRTP_RTCPStartingPort			= ulRTP_RTCPStartingPort;

		for (lRTSPSessionIndex = 0;
			lRTSPSessionIndex < (long) _ulMaxRTSPServerSessions;
			lRTSPSessionIndex++)
		{
			if ((_prsRTSPSessions [lRTSPSessionIndex]). init (
				lRTSPSessionIndex, _sStandard,
				&_esEventsSet,
				&_spStreamingServerSocketsPool,
				&_scScheduler,
				ulRTSP_RTCPTimeoutInSecs,
				ulPauseTimeoutInSecs,
				_ulFileCacheSizeInBytes,
				ulSendRTCPPacketsPeriodInMilliSecs,
				ulReceiveRTCPPacketsPeriodInMilliSecs,
				ulSendRTPMaxSleepTimeInMilliSecs,
				_pLocalIPAddressForRTSP,
				pLocalIPAddressForRTP,
				pLocalIPAddressForRTCP,
				_ulRTSPRequestsPort,
				dMaxSpeedAllowed,
				ulPlayDelayTimeInMilliSeconds,
				bIsOverBufferEnabled,
				ulSendingInterval,
				ulInitialWindowSizeInBytes,
				ulMaxSendAheadTimeInSec,
				fOverbufferRate,
				_pContentRootPath,
				&_mtLiveSources,
				_plsLiveSources,
				ulMaxLiveSourcesNumber,
				ulLocalRTP_RTCPStartingPort,
				ulLocalRTP_RTCPStartingPort +
				(ulRTP_RTCPReservedPorts / _ulMaxRTSPServerSessions) - 1,
				ulMaxPayloadSizeInBytes,
				ulRTPPacketsNumberToPrefetch,
				ulSamplesNumberToPrefetch,
				bUseOfHintingTrackIfExist,
				bBuildOfHintingTrackIfNotExist,
				pRequestLogFormat,
				&_mp4fMP4FileFactory,
				bAuthorizationActivated,
				pAuthorizationServletPathName,
				pAuthorizationWebServerIpAddress,
				ulAuthorizationWebServerPort,
				pAuthorizationLocalIPAddressForHTTP,
				ulAuthorizationHTTPRequestTimeoutInSecs,
				bCommitActivated,
				pCommitServletPathName,
				pCommitWebServerIpAddress,
				ulCommitWebServerPort,
				pCommitLocalIPAddressForHTTP,
				ulCommitHTTPRequestTimeoutInSecs,
				bFlushTraceAfterEachRequest,
				_ptSystemTracer,
				_ptSubscriberTracer) != errNoError)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_RTSPSESSION_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				_vFreeRTSPSessions. clear ();

				while (--lRTSPSessionIndex >= 0)
				{
					if ((_prsRTSPSessions [lRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				delete [] _prsRTSPSessions;
				_prsRTSPSessions			= (RTSPSession_p) NULL;

				if (_mtLiveSources. finish () != errNoError)
				{
					Error err = PThreadErrors (__FILE__, __LINE__,
						THREADLIB_PMUTEX_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				if (_spStreamingServerSocketsPool. finish () !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SCK_SOCKETSPOOL_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				if (_esEventsSet. finish () != errNoError)
				{
					Error err = EventsSetErrors (__FILE__, __LINE__,
						EVSET_EVENTSSET_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				delete [] _plsLiveSources;
				_plsLiveSources		= (LiveSource_p) NULL;

				if (_mp4fMP4FileFactory. finish () != errNoError)
				{
					Error err = MP4FileErrors (__FILE__, __LINE__,
						MP4F_MP4FILEFACTORY_INIT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				return err;
			}

			ulLocalRTP_RTCPStartingPort				+=
				(ulRTP_RTCPReservedPorts / _ulMaxRTSPServerSessions);

			_vFreeRTSPSessions. insert (_vFreeRTSPSessions. end (),
				&(_prsRTSPSessions [lRTSPSessionIndex]));
		}
	}

	// register CORBA
	{
		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"StreamingServer",
			"Name", _pStreamingName, SS_MAXSTREAMINGNAMELENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "StreamingServer", "Name");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			_vFreeRTSPSessions. clear ();

			{
				unsigned long			ulRTSPSessionIndex;

				for (ulRTSPSessionIndex = 0;
					ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
					ulRTSPSessionIndex++)
				{
					if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}
			}

			delete [] _prsRTSPSessions;
			_prsRTSPSessions			= (RTSPSession_p) NULL;

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
		strcat (_pStreamingName, "_Server");

		#ifdef HAVE_CORBA_H
			_pref				= (CORBA:: Object_var) NULL;

			{
				Message msg = StreamingServerMessages (__FILE__, __LINE__,
					SS_STREAMINGSERVER_CORBA_NAMEREGISTRATION,
					1, _pStreamingName);
				_ptSystemTracer -> trace (
					Tracer:: TRACER_LDBG5, (const char *) msg,
					__FILE__, __LINE__);
			}

			if (registerToNamingService (_pStreamingName) !=
				errNoError)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_REGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				_vFreeRTSPSessions. clear ();

				{
					unsigned long			ulRTSPSessionIndex;

					for (ulRTSPSessionIndex = 0;
						ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
						ulRTSPSessionIndex++)
					{
						if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
							errNoError)
						{
							Error err = StreamingServerErrors (
								__FILE__, __LINE__,
								SS_RTSPSESSION_FINISH_FAILED);
							_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
								(const char *) err, __FILE__, __LINE__);
						}
					}
				}

				delete [] _prsRTSPSessions;
				_prsRTSPSessions			= (RTSPSession_p) NULL;

				if (_mtLiveSources. finish () != errNoError)
				{
					Error err = PThreadErrors (__FILE__, __LINE__,
						THREADLIB_PMUTEX_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				if (_spStreamingServerSocketsPool. finish () !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SCK_SOCKETSPOOL_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				if (_esEventsSet. finish () != errNoError)
				{
					Error err = EventsSetErrors (__FILE__, __LINE__,
						EVSET_EVENTSSET_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				delete [] _plsLiveSources;
				_plsLiveSources		= (LiveSource_p) NULL;

				if (_mp4fMP4FileFactory. finish () != errNoError)
				{
					Error err = MP4FileErrors (__FILE__, __LINE__,
						MP4F_MP4FILEFACTORY_INIT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				return err;
			}
		#endif
	}

	/*
	PThreadSchedulingPolicy_t spSchedulingPolicy;
	_rsRTPSessions. getSchedulingPolicy (&spSchedulingPolicy);

	long		lPriority;
	_rsRTPSessions. getPriority (&lPriority);
	
	long ll = sched_get_priority_max(SCHED_FIFO);
	ll = sched_get_priority_max(SCHED_RR);
	ll = sched_get_priority_max(SCHED_OTHER);

	_rsRTPSessions. setPriority (ll);
	*/

	/*
	long lStackSize		= 3072 * 1024;
	if ((_prsRTSPSessions [ulRTSPSessionIndex]). setStackSize (
		lStackSize) != errNoError)
	{
		Error err = PThreadErrors (__FILE__, __LINE__,
			THREADLIB_PTHREAD_SETSTACKSIZE_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
			__FILE__, __LINE__);
			return err;
	}
	*/

	if (_mtStreamingServerStatistics. init (
		PMutex:: MUTEX_RECURSIVE) != errNoError)
	{
		Error err = PThreadErrors (__FILE__, __LINE__,
			THREADLIB_PMUTEX_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		#ifdef HAVE_CORBA_H
			if (deRegisterToNamingService (_pStreamingName) !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		#endif

		_vFreeRTSPSessions. clear ();

		{
			unsigned long			ulRTSPSessionIndex;

			for (ulRTSPSessionIndex = 0;
				ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
				ulRTSPSessionIndex++)
			{
				if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
					errNoError)
				{
					Error err = StreamingServerErrors (
						__FILE__, __LINE__,
						SS_RTSPSESSION_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _prsRTSPSessions;
		_prsRTSPSessions			= (RTSPSession_p) NULL;

		if (_mtLiveSources. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_spStreamingServerSocketsPool. finish () !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETSPOOL_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}

	if (_mtFreeRTSPSessions. init (
		PMutex:: MUTEX_RECURSIVE) != errNoError)
	{
		Error err = PThreadErrors (__FILE__, __LINE__,
			THREADLIB_PMUTEX_INIT_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		if (_mtStreamingServerStatistics. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		#ifdef HAVE_CORBA_H
			if (deRegisterToNamingService (_pStreamingName) !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		#endif

		_vFreeRTSPSessions. clear ();

		{
			unsigned long			ulRTSPSessionIndex;

			for (ulRTSPSessionIndex = 0;
				ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
				ulRTSPSessionIndex++)
			{
				if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
					errNoError)
				{
					Error err = StreamingServerErrors (
						__FILE__, __LINE__,
						SS_RTSPSESSION_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _prsRTSPSessions;
		_prsRTSPSessions			= (RTSPSession_p) NULL;

		if (_mtLiveSources. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_spStreamingServerSocketsPool. finish () !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETSPOOL_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}

	// server socket init
	{
		long					lMaxClients;
		Error_t					errServerSocketInit;
		SocketImpl_p			pServerSocketImpl;

		lMaxClients			= _ulMaxRTSPServerSessions;

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_RUNNING, 4,
				_pContentRootPath,
				_pLocalIPAddressForRTSP, _ulRTSPRequestsPort, lMaxClients);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if ((errServerSocketInit = _ssServerSocket. init (
			_pLocalIPAddressForRTSP, _ulRTSPRequestsPort, true,
			SocketImpl:: STREAM, 30, 0, 30, 0, lMaxClients)) !=
			errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errServerSocketInit,
				__FILE__, __LINE__);
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SERVERSOCKET_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (_mtFreeRTSPSessions. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtStreamingServerStatistics. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			#ifdef HAVE_CORBA_H
				if (deRegisterToNamingService (_pStreamingName) !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			#endif

			_vFreeRTSPSessions. clear ();

			{
				unsigned long			ulRTSPSessionIndex;

				for (ulRTSPSessionIndex = 0;
					ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
					ulRTSPSessionIndex++)
				{
					if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}
			}

			delete [] _prsRTSPSessions;
			_prsRTSPSessions			= (RTSPSession_p) NULL;

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if (_ssServerSocket. getSocketImpl (&pServerSocketImpl) != errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKET_GETSOCKETIMPL_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (_ssServerSocket. finish () != errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SERVERSOCKET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtFreeRTSPSessions. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtStreamingServerStatistics. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			#ifdef HAVE_CORBA_H
				if (deRegisterToNamingService (_pStreamingName) !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			#endif

			_vFreeRTSPSessions. clear ();

			{
				unsigned long			ulRTSPSessionIndex;

				for (ulRTSPSessionIndex = 0;
					ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
					ulRTSPSessionIndex++)
				{
					if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}
			}

			delete [] _prsRTSPSessions;
			_prsRTSPSessions			= (RTSPSession_p) NULL;

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if (pServerSocketImpl -> setBlocking (false) != errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETIMPL_SETBLOCKING_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (_ssServerSocket. finish () != errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SERVERSOCKET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtFreeRTSPSessions. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtStreamingServerStatistics. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			#ifdef HAVE_CORBA_H
				if (deRegisterToNamingService (_pStreamingName) !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			#endif

			_vFreeRTSPSessions. clear ();

			{
				unsigned long			ulRTSPSessionIndex;

				for (ulRTSPSessionIndex = 0;
					ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
					ulRTSPSessionIndex++)
				{
					if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}
			}

			delete [] _prsRTSPSessions;
			_prsRTSPSessions			= (RTSPSession_p) NULL;

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		if (pServerSocketImpl -> setMaxReceiveBuffer (32 * 1024) !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETIMPL_SETMAXRECEIVEBUFFER_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (_ssServerSocket. finish () != errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SERVERSOCKET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtFreeRTSPSessions. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtStreamingServerStatistics. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			#ifdef HAVE_CORBA_H
				if (deRegisterToNamingService (_pStreamingName) !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			#endif

			_vFreeRTSPSessions. clear ();

			{
				unsigned long			ulRTSPSessionIndex;

				for (ulRTSPSessionIndex = 0;
					ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
					ulRTSPSessionIndex++)
				{
					if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}
			}

			delete [] _prsRTSPSessions;
			_prsRTSPSessions			= (RTSPSession_p) NULL;

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}
	}

	{
		char					pLocalIPAddressForRTP [
			SCK_MAXIPADDRESSLENGTH];

		if ((errGetItemValue = _pcfConfiguration -> getItemValue (
			"IPConfiguration",
			"LocalIPAddressForRTP", pLocalIPAddressForRTP,
			SCK_MAXIPADDRESSLENGTH)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errGetItemValue,
				__FILE__, __LINE__);

			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETITEMVALUE_FAILED,
				2, "IPConfiguration", "LocalIPAddressForRTP");
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_ssServerSocket. finish () != errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SERVERSOCKET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtFreeRTSPSessions. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtStreamingServerStatistics. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			#ifdef HAVE_CORBA_H
				if (deRegisterToNamingService (_pStreamingName) !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			#endif

			_vFreeRTSPSessions. clear ();

			{
				unsigned long			ulRTSPSessionIndex;

				for (ulRTSPSessionIndex = 0;
					ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
					ulRTSPSessionIndex++)
				{
					if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}
			}

			delete [] _prsRTSPSessions;
			_prsRTSPSessions			= (RTSPSession_p) NULL;

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		// initialization processors
		if ((_pspStreamingServerProcessor = new StreamingServerProcessor_t [
			_ulStreamingServerProcessorsNumber]) ==
			(StreamingServerProcessor_p) NULL)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_NEW_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			if (_ssServerSocket. finish () != errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SERVERSOCKET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtFreeRTSPSessions. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_mtStreamingServerStatistics. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			#ifdef HAVE_CORBA_H
				if (deRegisterToNamingService (_pStreamingName) !=
					errNoError)
				{
					Error err = SocketErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			#endif

			_vFreeRTSPSessions. clear ();

			{
				unsigned long			ulRTSPSessionIndex;

				for (ulRTSPSessionIndex = 0;
					ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
					ulRTSPSessionIndex++)
				{
					if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
						errNoError)
					{
						Error err = StreamingServerErrors (
							__FILE__, __LINE__,
							SS_RTSPSESSION_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}
			}

			delete [] _prsRTSPSessions;
			_prsRTSPSessions			= (RTSPSession_p) NULL;

			if (_mtLiveSources. finish () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PMUTEX_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_spStreamingServerSocketsPool. finish () !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SCK_SOCKETSPOOL_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (_esEventsSet. finish () != errNoError)
			{
				Error err = EventsSetErrors (__FILE__, __LINE__,
					EVSET_EVENTSSET_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] _plsLiveSources;
			_plsLiveSources		= (LiveSource_p) NULL;

			if (_mp4fMP4FileFactory. finish () != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return err;
		}

		{
			long				lProcessorIdentifier;

			_ullTotalBytesServed				= 0;
			_ullTotalLostPacketsNumber			= 0;
			_ullTotalSentPacketsNumber			= 0;

			for (lProcessorIdentifier = 0; lProcessorIdentifier < _ulStreamingServerProcessorsNumber;
				lProcessorIdentifier++)
			{
				if ((_pspStreamingServerProcessor [lProcessorIdentifier]).
					init (
					lProcessorIdentifier,
					_sStandard,
					&_esEventsSet,
					&_ssServerSocket,
					&_spStreamingServerSocketsPool,
					_prsRTSPSessions,
					_ulMaxRTSPServerSessions,
					&_mtFreeRTSPSessions,
					&_vFreeRTSPSessions,
					pLocalIPAddressForRTP,
					&_mtStreamingServerStatistics,
					&_mtLiveSources,
					&_ullTotalBytesServed,
					&_ullTotalLostPacketsNumber,
					&_ullTotalSentPacketsNumber,
					_pcfConfiguration,
					_ptSystemTracer,
					_ptSubscriberTracer) != errNoError)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVERPROCESSOR_INIT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);

					while (--lProcessorIdentifier >= 0)
					{
						if ((_pspStreamingServerProcessor [lProcessorIdentifier]).
							finish () != errNoError)
						{
							Error err = StreamingServerErrors (__FILE__, __LINE__,
								SS_STREAMINGSERVERPROCESSOR_INIT_FAILED);
							_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
								(const char *) err, __FILE__, __LINE__);
						}
					}

					delete [] _pspStreamingServerProcessor;

					if (_ssServerSocket. finish () != errNoError)
					{
						Error err = SocketErrors (__FILE__, __LINE__,
							SCK_SERVERSOCKET_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (_mtFreeRTSPSessions. finish () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PMUTEX_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (_mtStreamingServerStatistics. finish () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PMUTEX_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					#ifdef HAVE_CORBA_H
						if (deRegisterToNamingService (_pStreamingName) !=
							errNoError)
						{
							Error err = SocketErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
							_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
								(const char *) err, __FILE__, __LINE__);
						}
					#endif

					_vFreeRTSPSessions. clear ();

					{
						unsigned long			ulRTSPSessionIndex;

						for (ulRTSPSessionIndex = 0;
							ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
							ulRTSPSessionIndex++)
						{
							if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
								errNoError)
							{
								Error err = StreamingServerErrors (
									__FILE__, __LINE__,
									SS_RTSPSESSION_FINISH_FAILED);
								_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
									(const char *) err, __FILE__, __LINE__);
							}
						}
					}

					delete [] _prsRTSPSessions;
					_prsRTSPSessions			= (RTSPSession_p) NULL;

					if (_mtLiveSources. finish () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PMUTEX_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (_spStreamingServerSocketsPool. finish () !=
						errNoError)
					{
						Error err = SocketErrors (__FILE__, __LINE__,
							SCK_SOCKETSPOOL_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (_esEventsSet. finish () != errNoError)
					{
						Error err = EventsSetErrors (__FILE__, __LINE__,
							EVSET_EVENTSSET_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					delete [] _plsLiveSources;
					_plsLiveSources		= (LiveSource_p) NULL;

					if (_mp4fMP4FileFactory. finish () != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_INIT_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return err;
				}
			}
		}
	}

	// initialization of the scheduler
	if (_scScheduler. init (
		_ulSchedulerSleepTimeInMilliSecs) != errNoError)
	{
		Error err = SchedulerErrors (__FILE__, __LINE__,
			SCH_SCHEDULER_INIT_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err,
			__FILE__, __LINE__);

		{
			unsigned long			ulProcessorIdentifier;

			for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
				ulProcessorIdentifier++)
			{
				if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
					finish () != errNoError)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVERPROCESSOR_INIT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _pspStreamingServerProcessor;

		if (_ssServerSocket. finish () != errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SERVERSOCKET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtFreeRTSPSessions. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtStreamingServerStatistics. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		#ifdef HAVE_CORBA_H
			if (deRegisterToNamingService (_pStreamingName) !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		#endif

		_vFreeRTSPSessions. clear ();

		{
			unsigned long			ulRTSPSessionIndex;

			for (ulRTSPSessionIndex = 0;
				ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
				ulRTSPSessionIndex++)
			{
				if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
					errNoError)
				{
					Error err = StreamingServerErrors (
						__FILE__, __LINE__,
						SS_RTSPSESSION_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _prsRTSPSessions;
		_prsRTSPSessions			= (RTSPSession_p) NULL;

		if (_mtLiveSources. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_spStreamingServerSocketsPool. finish () !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETSPOOL_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}

	if (_cspCheckSocketsPoolTimes. init (
		_ulCheckSocketsPoolPeriodInMilliSecs,
		&_spStreamingServerSocketsPool,
		_ptSystemTracer) != errNoError)
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_CHECKSOCKETSPOOLTIMES_INIT_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		// bDestroyTimes
		if (_scScheduler. finish (true) != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		{
			unsigned long			ulProcessorIdentifier;

			for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
				ulProcessorIdentifier++)
			{
				if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
					finish () != errNoError)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVERPROCESSOR_INIT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _pspStreamingServerProcessor;

		if (_ssServerSocket. finish () != errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SERVERSOCKET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtFreeRTSPSessions. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtStreamingServerStatistics. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		#ifdef HAVE_CORBA_H
			if (deRegisterToNamingService (_pStreamingName) !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		#endif

		_vFreeRTSPSessions. clear ();

		{
			unsigned long			ulRTSPSessionIndex;

			for (ulRTSPSessionIndex = 0;
				ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
				ulRTSPSessionIndex++)
			{
				if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
					errNoError)
				{
					Error err = StreamingServerErrors (
						__FILE__, __LINE__,
						SS_RTSPSESSION_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _prsRTSPSessions;
		_prsRTSPSessions			= (RTSPSession_p) NULL;

		if (_mtLiveSources. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_spStreamingServerSocketsPool. finish () !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETSPOOL_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}

	if (_cssCheckServerSocketTimes. init (
		_ulCheckServerSocketPeriodInMilliSecs, &_esEventsSet,
		_ptSystemTracer) != errNoError)
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_CHECKSERVERSOCKETTIMES_INIT_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		if (_cspCheckSocketsPoolTimes. finish () != errNoError)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CHECKSOCKETSPOOLTIMES_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		// bDestroyTimes
		if (_scScheduler. finish (true) != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		{
			unsigned long			ulProcessorIdentifier;

			for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
				ulProcessorIdentifier++)
			{
				if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
					finish () != errNoError)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVERPROCESSOR_INIT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _pspStreamingServerProcessor;

		if (_ssServerSocket. finish () != errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SERVERSOCKET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtFreeRTSPSessions. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtStreamingServerStatistics. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		#ifdef HAVE_CORBA_H
			if (deRegisterToNamingService (_pStreamingName) !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		#endif

		_vFreeRTSPSessions. clear ();

		{
			unsigned long			ulRTSPSessionIndex;

			for (ulRTSPSessionIndex = 0;
				ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
				ulRTSPSessionIndex++)
			{
				if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
					errNoError)
				{
					Error err = StreamingServerErrors (
						__FILE__, __LINE__,
						SS_RTSPSESSION_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _prsRTSPSessions;
		_prsRTSPSessions			= (RTSPSession_p) NULL;

		if (_mtLiveSources. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_spStreamingServerSocketsPool. finish () !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETSPOOL_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}

	if (initNICs (&_vIPAddresses) != errNoError)
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_STREAMINGSERVER_INITNICS_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		if (_cssCheckServerSocketTimes. finish () != errNoError)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CHECKSERVERSOCKETTIMES_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_cspCheckSocketsPoolTimes. finish () != errNoError)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CHECKSOCKETSPOOLTIMES_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		// bDestroyTimes
		if (_scScheduler. finish (true) != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		{
			unsigned long			ulProcessorIdentifier;

			for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
				ulProcessorIdentifier++)
			{
				if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
					finish () != errNoError)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVERPROCESSOR_INIT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _pspStreamingServerProcessor;

		if (_ssServerSocket. finish () != errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SERVERSOCKET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtFreeRTSPSessions. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_mtStreamingServerStatistics. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		#ifdef HAVE_CORBA_H
			if (deRegisterToNamingService (_pStreamingName) !=
				errNoError)
			{
				Error err = SocketErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		#endif

		_vFreeRTSPSessions. clear ();

		{
			unsigned long			ulRTSPSessionIndex;

			for (ulRTSPSessionIndex = 0;
				ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
				ulRTSPSessionIndex++)
			{
				if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
					errNoError)
				{
					Error err = StreamingServerErrors (
						__FILE__, __LINE__,
						SS_RTSPSESSION_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}
		}

		delete [] _prsRTSPSessions;
		_prsRTSPSessions			= (RTSPSession_p) NULL;

		if (_mtLiveSources. finish () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_spStreamingServerSocketsPool. finish () !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SCK_SOCKETSPOOL_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		if (_esEventsSet. finish () != errNoError)
		{
			Error err = EventsSetErrors (__FILE__, __LINE__,
				EVSET_EVENTSSET_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		delete [] _plsLiveSources;
		_plsLiveSources		= (LiveSource_p) NULL;

		if (_mp4fMP4FileFactory. finish () != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}

		return err;
	}


	return errNoError;
}


Error StreamingServer:: finish ()

{

	if (finishNICs (&_vIPAddresses) != errNoError)
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_STREAMINGSERVER_FINISHNICS_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	if (_cssCheckServerSocketTimes. finish () != errNoError)
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_CHECKSERVERSOCKETTIMES_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	if (_cspCheckSocketsPoolTimes. finish () != errNoError)
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_CHECKSOCKETSPOOLTIMES_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	// bDestroyTimes
	if (_scScheduler. finish (true) != errNoError)
	{
		Error err = SchedulerErrors (__FILE__, __LINE__,
			SCH_SCHEDULER_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err,
			__FILE__, __LINE__);
	}

	{
		unsigned long			ulProcessorIdentifier;

		for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
			ulProcessorIdentifier++)
		{
			if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
				finish () != errNoError)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVERPROCESSOR_INIT_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}
	}

	delete [] _pspStreamingServerProcessor;

	if (_ssServerSocket. finish () != errNoError)
	{
		Error err = SocketErrors (__FILE__, __LINE__,
			SCK_SERVERSOCKET_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	if (_mtFreeRTSPSessions. finish () != errNoError)
	{
		Error err = PThreadErrors (__FILE__, __LINE__,
			THREADLIB_PMUTEX_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	if (_mtStreamingServerStatistics. finish () != errNoError)
	{
		Error err = PThreadErrors (__FILE__, __LINE__,
			THREADLIB_PMUTEX_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	#ifdef HAVE_CORBA_H
		if (deRegisterToNamingService (_pStreamingName) !=
			errNoError)
		{
			Error err = SocketErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		}
	#endif

	_vFreeRTSPSessions. clear ();

	{
		unsigned long			ulRTSPSessionIndex;

		for (ulRTSPSessionIndex = 0;
			ulRTSPSessionIndex < _ulMaxRTSPServerSessions;
			ulRTSPSessionIndex++)
		{
			if ((_prsRTSPSessions [ulRTSPSessionIndex]). finish () !=
				errNoError)
			{
				Error err = StreamingServerErrors (
					__FILE__, __LINE__,
					SS_RTSPSESSION_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}
	}

	delete [] _prsRTSPSessions;
	_prsRTSPSessions			= (RTSPSession_p) NULL;

	if (_mtLiveSources. finish () != errNoError)
	{
		Error err = PThreadErrors (__FILE__, __LINE__,
			THREADLIB_PMUTEX_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	if (_spStreamingServerSocketsPool. finish () != errNoError)
	{
		Error err = SocketErrors (__FILE__, __LINE__,
			SCK_SOCKETSPOOL_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	if (_esEventsSet. finish () != errNoError)
	{
		Error err = EventsSetErrors (__FILE__, __LINE__,
			EVSET_EVENTSSET_FINISH_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}

	delete [] _plsLiveSources;
	_plsLiveSources		= (LiveSource_p) NULL;

	if (_mp4fMP4FileFactory. finish () != errNoError)
	{
		Error err = MP4FileErrors (__FILE__, __LINE__,
			MP4F_MP4FILEFACTORY_INIT_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	}


	return errNoError;
}


Error StreamingServer:: start (void)

{

	unsigned long			ulProcessorIdentifier;
	Error_t					errProcessor;
	Error_t					errJoin;


	_tServerStartTime						= time (NULL);

	// start Processor
	for (ulProcessorIdentifier = 0;
		ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
		ulProcessorIdentifier++)
	{
		/*
		{
			long		lStackSize;
			char		pBuff [1024];

			lStackSize		= 20480 * 1024;
			if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
				setStackSize (lStackSize) != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_SETSTACKSIZE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
				getStackSize (&lStackSize) != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_SETSTACKSIZE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
			sprintf (pBuff, "Stack size: %ld", lStackSize);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, pBuff,
				__FILE__, __LINE__);
		}
		*/

		if ((_pspStreamingServerProcessor [ulProcessorIdentifier]). start () !=
			errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PTHREAD_START_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);

			while (--ulProcessorIdentifier >= 0)
			{
				if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
					cancel () != errNoError)
				{
					Error err = PThreadErrors (__FILE__, __LINE__,
						THREADLIB_PTHREAD_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}

			return err;
		}
	}

	// start scheduler
	{
		if (_scScheduler. start () != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_START_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);

			for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
				ulProcessorIdentifier++)
			{
				if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
					cancel () != errNoError)
				{
					Error err = PThreadErrors (__FILE__, __LINE__,
						THREADLIB_PTHREAD_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}

			return err;
		}
	}

	{
		unsigned long			ulRTSPSessionIdentifier;
		RTSP_RTCPTimes_p		prrRTSP_RTCPTimes;
		PauseTimes_p			pptPauseTimes;
		SendRTCPPacketsTimes_p	psrptSendRTCPPacketsTimes;
		CheckReceivedRTCPPacketsTimes_p	pcrrptCheckReceivedRTCPPacketsTimes;


		for (ulRTSPSessionIdentifier = 0;
			ulRTSPSessionIdentifier < _ulMaxRTSPServerSessions;
			ulRTSPSessionIdentifier++)
		{
			if ((_prsRTSPSessions [ulRTSPSessionIdentifier]).
				getRTSP_RTCPTimes (&prrRTSP_RTCPTimes) != errNoError)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_RTSPSESSION_GETRTSP_RTCPTIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}

			if ((_prsRTSPSessions [ulRTSPSessionIdentifier]). getPauseTimes (
				&pptPauseTimes) != errNoError)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_RTSPSESSION_GETPAUSETIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}

			if ((_prsRTSPSessions [ulRTSPSessionIdentifier]).
				getSendRTCPPacketsTimes (&psrptSendRTCPPacketsTimes) !=
				errNoError)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_RTSPSESSION_GETSENDRTSPPACKETSTIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}

			if ((_prsRTSPSessions [ulRTSPSessionIdentifier]).
				getCheckReceivedRTCPPacketsTimes (
				&pcrrptCheckReceivedRTCPPacketsTimes) != errNoError)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_RTSPSESSION_GETCHECKRECEIVEDRTSPPACKETSTIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}

			if (_scScheduler. activeTimes (prrRTSP_RTCPTimes) !=
				errNoError)
			{
				Error err = SchedulerErrors (__FILE__, __LINE__,
					SCH_SCHEDULER_ACTIVETIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err,
					__FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}

			if (_scScheduler. activeTimes (pptPauseTimes) !=
				errNoError)
			{
				Error err = SchedulerErrors (__FILE__, __LINE__,
					SCH_SCHEDULER_ACTIVETIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err,
					__FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}

			if (_scScheduler. activeTimes (psrptSendRTCPPacketsTimes) !=
				errNoError)
			{
				Error err = SchedulerErrors (__FILE__, __LINE__,
					SCH_SCHEDULER_ACTIVETIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err,
					__FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}

			if (_scScheduler. activeTimes (
				pcrrptCheckReceivedRTCPPacketsTimes) != errNoError)
			{
				Error err = SchedulerErrors (__FILE__, __LINE__,
					SCH_SCHEDULER_ACTIVETIMES_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err,
					__FILE__, __LINE__);

				if (_scScheduler. cancel () != errNoError)
				{
					Error err = SchedulerErrors (__FILE__, __LINE__,
						SCH_SCHEDULER_CANCEL_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err,
						__FILE__, __LINE__);
				}

				for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
					ulProcessorIdentifier++)
				{
					if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
						cancel () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PTHREAD_CANCEL_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}
				}

				return err;
			}
		}
	}

	if (_cspCheckSocketsPoolTimes. start () != errNoError)
	{
		Error err = SchedulerErrors (__FILE__, __LINE__,
			SCH_TIMES_START_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err,
			__FILE__, __LINE__);

		if (_scScheduler. cancel () != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_CANCEL_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
			ulProcessorIdentifier++)
		{
			if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
				cancel () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_CANCEL_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}

		return err;
	}

	if (_scScheduler. activeTimes (&_cspCheckSocketsPoolTimes) !=
		errNoError)
	{
		Error err = SchedulerErrors (__FILE__, __LINE__,
			SCH_SCHEDULER_ACTIVETIMES_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err,
			__FILE__, __LINE__);

		if (_scScheduler. cancel () != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_CANCEL_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
			ulProcessorIdentifier++)
		{
			if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
				cancel () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_CANCEL_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}

		return err;
	}

	if (_scScheduler. activeTimes (&_cssCheckServerSocketTimes) !=
		errNoError)
	{
		Error err = SchedulerErrors (__FILE__, __LINE__,
			SCH_SCHEDULER_ACTIVETIMES_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err,
			__FILE__, __LINE__);

		if (_scScheduler. cancel () != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_CANCEL_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
			ulProcessorIdentifier++)
		{
			if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
				cancel () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_CANCEL_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}

		return err;
	}

	if (activate ())
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SS_STREAMINGSERVER_ACTIVATE_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		if (_scScheduler. cancel () != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_CANCEL_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		for (ulProcessorIdentifier = 0; ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
			ulProcessorIdentifier++)
		{
			if ((_pspStreamingServerProcessor [ulProcessorIdentifier]).
				cancel () != errNoError)
			{
				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_CANCEL_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}

		return err;
	}

	#ifdef HAVE_CORBA_H
		_pmgr -> activate ();
		_porb -> run ();

		_poa -> destroy (TRUE, TRUE);
		_pmgr -> deactivate (TRUE, TRUE);

		if (_scScheduler. cancel () != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_CANCEL_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}

		for (ulProcessorIdentifier = 0;
			ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
			ulProcessorIdentifier++)
		{
			if ((errProcessor = (_pspStreamingServerProcessor [
				ulProcessorIdentifier]). join (&errJoin)) != errNoError)
			{
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) errProcessor, __FILE__, __LINE__);

				if (errJoin != errNoError)
				{
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) errJoin, __FILE__, __LINE__);

					Error err = PThreadErrors (__FILE__, __LINE__,
						THREADLIB_PTHREAD_JOIN_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}

			if (errJoin != errNoError)
			{
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) errJoin, __FILE__, __LINE__);

				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_JOIN_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}
	#else
		for (ulProcessorIdentifier = 0;
			ulProcessorIdentifier < _ulStreamingServerProcessorsNumber;
			ulProcessorIdentifier++)
		{
			if ((errProcessor = (_pspStreamingServerProcessor [
				ulProcessorIdentifier]). join (&errJoin)) != errNoError)
			{
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) errProcessor, __FILE__, __LINE__);

				if (errJoin != errNoError)
				{
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) errJoin, __FILE__, __LINE__);

					Error err = PThreadErrors (__FILE__, __LINE__,
						THREADLIB_PTHREAD_JOIN_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}
			}

			if (errJoin != errNoError)
			{
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) errJoin, __FILE__, __LINE__);

				Error err = PThreadErrors (__FILE__, __LINE__,
					THREADLIB_PTHREAD_JOIN_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}
		}

		if (_scScheduler. cancel () != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_SCHEDULER_CANCEL_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err,
				__FILE__, __LINE__);
		}
	#endif



	return errNoError;
}


Error StreamingServer:: initNICs (
	std:: vector<SocketImpl:: IPAddress_t> *pvIPAddresses)

{


	if (SocketImpl:: getIPAddressesList (pvIPAddresses) !=
		errNoError)
	{
		Error err = StreamingServerErrors (__FILE__, __LINE__,
			SCK_SOCKETIMPL_GETIPADDRESSESLIST_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);

		return err;
	}



	return errNoError;
}


Error StreamingServer:: finishNICs (
	std:: vector<SocketImpl:: IPAddress_t> *pvIPAddresses)

{

	pvIPAddresses -> clear ();


	return errNoError;
}


#ifdef HAVE_CORBA_H
	CORBA:: Long StreamingServer:: activate ()
#else
	long StreamingServer:: activate ()
#endif

{

	#ifdef HAVE_CORBA_H
		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_ACTIVATE);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG5, (const char *) msg,
				__FILE__, __LINE__);
		}
	#endif

	if (_cssCheckServerSocketTimes. start () != errNoError)
	{
		Error err = SchedulerErrors (__FILE__, __LINE__,
			SCH_TIMES_START_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	
		return 1;
	}


	return 0;
}


#ifdef HAVE_CORBA_H
	CORBA:: Long StreamingServer:: deactivate ()
#else
	long StreamingServer:: deactivate ()
#endif

{

	#ifdef HAVE_CORBA_H
		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_DEACTIVATE);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG5, (const char *) msg,
				__FILE__, __LINE__);
		}
	#endif

	if (_cssCheckServerSocketTimes. stop () != errNoError)
	{
		Error err = SchedulerErrors (__FILE__, __LINE__,
			SCH_TIMES_STOP_FAILED);
		_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
			(const char *) err, __FILE__, __LINE__);
	
		return 1;
	}


	return 0;
}


#ifdef HAVE_CORBA_H
	Error StreamingServer:: registerToNamingService (
		const char *pStreamingServerName)

	{

		try
		{
			// POA initialization
			_poid			= _poa -> activate_object (this);
			_pref			= _poa -> id_to_reference (*_poid);

			CORBA::Object_var nsobj					=
				_porb -> resolve_initial_references ("NameService");

			CosNaming::NamingContext_var pnc			=
				CosNaming::NamingContext::_narrow (nsobj);

			if (CORBA::is_nil (pnc))
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_REGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (
					Tracer:: TRACER_LERRR, (const char *) err,
					__FILE__, __LINE__);

				_poa -> deactivate_object (*_poid);
				_pref		= (CORBA:: Object_var) NULL;

				return err;
			}

			{
				CosNaming:: Name			name;
				name. length (1);
				name [0]. id			= CORBA::string_dup (
					pStreamingServerName);
				name [0]. kind			= CORBA::string_dup ("");
	
				// rebind because if it is alread binded
				//	we will receive an error
				pnc -> rebind (name, _pref);
			}
		}
		catch (CosNaming::NamingContext::NotFound &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTNOTFOUND);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			_poa -> deactivate_object (*_poid);
			_pref		= (CORBA:: Object_var) NULL;

			return err;
		}
		catch (CosNaming::NamingContext::CannotProceed &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTCANNOTPROCEED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			_poa -> deactivate_object (*_poid);
			_pref		= (CORBA:: Object_var) NULL;

			return err;
		}
		catch (CosNaming::NamingContext::InvalidName &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTINVALIDNAME);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			_poa -> deactivate_object (*_poid);
			_pref		= (CORBA:: Object_var) NULL;

			return err;
		}
		catch (CORBA::SystemException &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTGENERICERROR);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			_poa -> deactivate_object (*_poid);
			_pref		= (CORBA:: Object_var) NULL;

			return err;
		}
		catch (...)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CORBA_GENERICERROR);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			_poa -> deactivate_object (*_poid);
			_pref		= (CORBA:: Object_var) NULL;

			return err;
		}


		return errNoError;
	}


	Error StreamingServer:: deRegisterToNamingService (
		const char *pStreamingServerName)

	{

		try
		{
			CORBA::Object_var nsobj					=
				_porb -> resolve_initial_references ("NameService");

			CosNaming::NamingContext_var pnc			=
				CosNaming::NamingContext::_narrow (nsobj);

			if (CORBA::is_nil (pnc))
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_DEREGISTERTONAMINGSERVICE_FAILED);
				_ptSystemTracer -> trace (
					Tracer:: TRACER_LERRR, (const char *) err,
					__FILE__, __LINE__);

				return err;
			}

			{
				CosNaming:: Name			name;
				name. length (1);
				name [0]. id		= CORBA::string_dup (pStreamingServerName);
				name [0]. kind		= CORBA::string_dup ("");
	
				pnc -> unbind (name);
			}

			// _poa -> deactivate_object (*(_poa -> servant_to_id (this)));
			// _poa -> deactivate_object (*_poid); moved in shutdown because exception
			_pref		= (CORBA:: Object_var) NULL;
		}
		catch (CosNaming::NamingContext::NotFound &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTNOTFOUND);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		catch (CosNaming::NamingContext::CannotProceed &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTCANNOTPROCEED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		catch (CosNaming::NamingContext::InvalidName &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTINVALIDNAME);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		catch (CORBA::SystemException &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_NAMINGCONTEXTGENERICERROR);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}
		catch (...)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CORBA_GENERICERROR);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return err;
		}


		return errNoError;
	}


	CORBA:: Long StreamingServer:: prova ()

	{

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_PROVA);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG5, (const char *) msg,
				__FILE__, __LINE__);
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: shutdown ()

	{

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_SHUTDOWN);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG5, (const char *) msg,
				__FILE__, __LINE__);
		}

		try
		{
			_poa -> deactivate_object (*_poid);
			_porb -> shutdown (FALSE);
		}
		catch (CORBA::SystemException &)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_STREAMINGSERVER_SHUTDOWNCORBAFAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err); 
		}
		catch (...)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_CORBA_GENERICERROR);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return 2;
		}


		return 0;
	}


	CORBA::Long StreamingServer:: isRequestInCache (
		const char *pAssetPath,
		CORBA:: ULong_out bIsInCache,
		CORBA:: ULong_out ulConnectedUsers,
		CORBA:: ULong_out ulBandWidthUsageInbps)

	{

		/*
		Boolean_t				bIsLive;
		Boolean_t				bIsRequestInCache;
		RTSPSession_p			prsRTSPSession;
		std:: vector<RTSPSession_p>:: iterator		it;
		unsigned long			ulAudioBitRate;
		unsigned long			ulVideoBitRate;
		Error					errGetAvgBitRate;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_ISREQUESTINCACHE,
				1, pAssetPath);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG5, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (RTSPSession:: isLiveRequest (pAssetPath, &bIsLive) !=
			errNoError)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_RTSPSESSION_ISLIVEREQUEST_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR, (const char *) err,
				__FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bIsLive)
		{
			bIsRequestInCache		= true;
		}
		else
		{
			if (_mp4fMP4FileFactory. isMP4FileInCache (
				pAssetPath, &bIsRequestInCache) != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_ISMP4FILEINCACHE_FAILED);
				_ptSystemTracer -> trace (
					Tracer:: TRACER_LERRR, (const char *) err,
					__FILE__, __LINE__);

				return 2;
				// throw ::StreamingIDL:: StreamingExc ((const char *) err);
			}
		}

		bIsInCache					= bIsRequestInCache;

		if (_mtActiveRTSPSessions. lock () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_LOCK_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 3;
		}

		ulConnectedUsers			= _vActiveRTSPSessions. size ();

		ulBandWidthUsageInbps		= 0;

		for (it = _vActiveRTSPSessions. begin ();
			it != _vActiveRTSPSessions. end ();
			++it)
		{
			prsRTSPSession			= *it;

			if ((errGetAvgBitRate =
				prsRTSPSession -> getAvgBitRate (&ulAudioBitRate,
				&ulVideoBitRate)) != errNoError)
			{
				if ((long) errGetAvgBitRate == SS_RTSPSESSION_WRONGSTATE)
				{
					ulAudioBitRate			= 0;
					ulVideoBitRate			= 0;
				}
				else
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_RTSPSESSION_GETAVGBITRATE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mtActiveRTSPSessions. unLock () != errNoError)
					{
						Error err = PThreadErrors (__FILE__, __LINE__,
							THREADLIB_PMUTEX_UNLOCK_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 4;
				}
			}

			ulBandWidthUsageInbps		+= (ulAudioBitRate +
				ulVideoBitRate);
		}

		if (_mtActiveRTSPSessions. unLock () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_UNLOCK_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 5;
		}

		ulBandWidthUsageInbps		*= 1000;


		*/
		return 0;
	}


	CORBA:: Long StreamingServer:: setChangedConfiguration (
		const ::StreamingIDL:: ConfigurationItemsList &
		cilConfigurationItemsList)

	{
		long				lChangedConfigurationItemsNumber;
		long				lChangedConfigurationItemIndex;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_SETCHANGEDCONFIGURATION);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}


		lChangedConfigurationItemsNumber		=
			cilConfigurationItemsList. length ();

		if (lChangedConfigurationItemsNumber > 0)
		{
			for (lChangedConfigurationItemIndex = 0;
				lChangedConfigurationItemIndex <
				lChangedConfigurationItemsNumber;
				lChangedConfigurationItemIndex++)
			{
				if (_pcfConfiguration -> modifyItemValue (
					cilConfigurationItemsList [
					lChangedConfigurationItemIndex]. pSectionName,
					cilConfigurationItemsList [
					lChangedConfigurationItemIndex]. pItemName,
					cilConfigurationItemsList [
					lChangedConfigurationItemIndex]. pItemValue) !=
					errNoError)
				{
					Error err = ConfigurationErrors (__FILE__, __LINE__,
						CFG_CONFIG_MODIFYITEMVALUE_FAILED);
					_ptSystemTracer -> trace (
						Tracer:: TRACER_LERRR, (const char *) err,
						__FILE__, __LINE__);

					return 1;
					// throw ::StreamingIDL:: StreamingExc ((const char *) err); 
				}
			}

			if (_pcfConfiguration -> save () != errNoError)
			{
				Error err = ConfigurationFileErrors (__FILE__, __LINE__,
					CFGFILE_CONFIGURATIONFILE_SAVE_FAILED);
				_ptSystemTracer -> trace (
					Tracer:: TRACER_LERRR, (const char *) err,
					__FILE__, __LINE__);

				return 2;
				// throw ::StreamingIDL:: StreamingExc ((const char *) err); 
			}
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: getConfiguration (
		::StreamingIDL:: ConfigurationItemsWithInfoList_out
		cilConfigurationItemsWithInfoList)

	{

		long					lSectionsNumber;
		long					lSectionIndex;
		ConfigurationSection_t	csCfgSection;
		long					lItemsNumber;
		long					lItemIndex;
		ConfigurationItem_t		ciCfgItem;
		char					pSectionName [SS_MAXSECTIONNAMELENGTH];
		char					pItemComment [SS_MAXITEMCOMMENTLENGTH];
		char					pItemName [SS_MAXITEMNAMELENGTH];
		char					pItemValue [SS_MAXITEMVALUELENGTH];
		Error_t					errGetCfgItem;
		::StreamingIDL:: ConfigurationItemsWithInfoList
			cilLocalConfigurationItemsWithInfoList (SS_MAXCONFIGURATIONITEMS);



		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_GETCONFIGURATION);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		cilLocalConfigurationItemsWithInfoList. length (0);

		if (_pcfConfiguration -> getSectionsNumber (&lSectionsNumber) !=
			errNoError)
		{
			Error err = ConfigurationErrors (__FILE__, __LINE__,
				CFG_CONFIG_GETSECTIONSNUMBER_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err); 
		}

		for (lSectionIndex = 0; lSectionIndex < lSectionsNumber;
			lSectionIndex++)
		{
			if (_pcfConfiguration -> getCfgSectionByIndex (
				lSectionIndex, &csCfgSection) != errNoError)
			{
				Error err = ConfigurationErrors (__FILE__, __LINE__,
					CFG_CONFIG_GETCFGSECTIONBYINDEX_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				return 2;
				// throw ::StreamingIDL:: StreamingExc ((const char *) err);
			}

			if (csCfgSection. getSectionName (pSectionName) != errNoError)
			{
				Error err = ConfigurationErrors (__FILE__, __LINE__,
					CFG_CONFIGURATIONSECTION_GETSECTIONNAME_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				return 3;
				// throw ::StreamingIDL:: StreamingExc ((const char *) err);
			}

			if (_pcfConfiguration -> getItemsNumber (lSectionIndex,
				&lItemsNumber) != errNoError)
			{
				Error err = ConfigurationErrors (__FILE__, __LINE__,
					CFG_CONFIG_GETITEMSNUMBER_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				return 4;
				// throw ::StreamingIDL:: StreamingExc ((const char *) err);
			}

			if (cilLocalConfigurationItemsWithInfoList. length () +
				lItemsNumber > SS_MAXCONFIGURATIONITEMS)
			{
				Error err = StreamingServerErrors (__FILE__, __LINE__,
					SS_STREAMINGSERVER_LISTTOOLONG);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				return 5;
				// throw ::StreamingIDL:: StreamingExc ((const char *) err);
			}

			cilLocalConfigurationItemsWithInfoList. length (
				cilLocalConfigurationItemsWithInfoList. length () +
				lItemsNumber);

			for (lItemIndex = 0; lItemIndex < lItemsNumber; lItemIndex++)
			{
				if ((errGetCfgItem = _pcfConfiguration -> getCfgItemByIndex (
					lSectionIndex, lItemIndex, &ciCfgItem)) != errNoError)
				{
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) errGetCfgItem, __FILE__, __LINE__);

					Error err = ConfigurationErrors (__FILE__, __LINE__,
						CFG_CONFIG_GETCFGITEMBYINDEX_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					return 6;
					// throw ::StreamingIDL:: StreamingExc (
					//	(const char *) err);
				}

				if (ciCfgItem. getItemComment (pItemComment) != errNoError)
				{
					Error err = ConfigurationErrors (__FILE__, __LINE__,
						CFG_CONFIGURATIONITEM_GETITEMCOMMENT_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					return 7;
					// throw ::StreamingIDL:: StreamingExc (
					//	(const char *) err);
				}

				if ((errGetCfgItem = ciCfgItem. getItemName (pItemName)) !=
					errNoError)
				{
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) errGetCfgItem, __FILE__, __LINE__);

					Error err = ConfigurationErrors (__FILE__, __LINE__,
						CFG_CONFIGURATIONITEM_GETITEMNAME_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					return 8;
					// throw ::StreamingIDL:: StreamingExc (
					//	(const char *) err);
				}

				if (
					(!strcmp (pSectionName, "StreamingServer") &&
					!strcmp (pItemName, "Name")) ||
					(!strcmp (pSectionName, "System") &&
					!strcmp (pItemName, "License"))
					)
				{
					cilLocalConfigurationItemsWithInfoList. length (
						cilLocalConfigurationItemsWithInfoList. length () - 1);

					if (ciCfgItem. finish () != errNoError)
					{
						Error err = ConfigurationErrors (__FILE__, __LINE__,
							CFG_CONFIGURATIONITEM_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);

						return 9;
						// throw ::StreamingIDL:: StreamingExc (
						//	(const char *) err);
					}

					continue;
				}

				if (ciCfgItem. getItemValue (pItemValue,
					SS_MAXITEMVALUELENGTH) != errNoError)
				{
					Error err = ConfigurationErrors (__FILE__, __LINE__,
						CFG_CONFIGURATIONITEM_GETITEMVALUE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					return 10;
					// throw ::StreamingIDL:: StreamingExc (
					//	(const char *) err);
				}

				cilLocalConfigurationItemsWithInfoList [
					cilLocalConfigurationItemsWithInfoList.length () -
					lItemsNumber + lItemIndex]. ciConfigurationItem.
					pSectionName					=
					CORBA:: string_dup (pSectionName);
				cilLocalConfigurationItemsWithInfoList [
					cilLocalConfigurationItemsWithInfoList.length () -
					lItemsNumber + lItemIndex]. ciConfigurationItem.
					pItemComment						=
					CORBA:: string_dup (pItemComment);
				cilLocalConfigurationItemsWithInfoList [
					cilLocalConfigurationItemsWithInfoList.length () -
					lItemsNumber + lItemIndex]. ciConfigurationItem.
					pItemName						=
					CORBA:: string_dup (pItemName);
				cilLocalConfigurationItemsWithInfoList [
					cilLocalConfigurationItemsWithInfoList.length () -
					lItemsNumber + lItemIndex]. ciConfigurationItem.
					pItemValue					=
					CORBA:: string_dup (pItemValue);

				cilLocalConfigurationItemsWithInfoList [
					cilLocalConfigurationItemsWithInfoList.length () -
					lItemsNumber + lItemIndex]. itItemType				=
					::StreamingIDL:: NUMBER;

				if (
					(!strcmp (pSectionName, "IPConfiguration") &&
					!strcmp (pItemName, "LocalIPAddressForRTSP")) ||
					(!strcmp (pSectionName, "IPConfiguration") &&
					!strcmp (pItemName, "LocalIPAddressForRTP")) ||
					(!strcmp (pSectionName, "IPConfiguration") &&
					!strcmp (pItemName, "LocalIPAddressForRTCP")) ||
					(!strcmp (pSectionName, "Authorization") &&
					!strcmp (pItemName, "LocalIPAddressForHTTP")) ||
					(!strcmp (pSectionName, "Commit") &&
					!strcmp (pItemName, "LocalIPAddressForHTTP"))
					)
				{
					std:: vector<SocketImpl:: IPAddress_t>:: const_iterator
						it;
					SocketImpl:: IPAddress_t				iaIPAddress;
					char							pIPAddressLabel [
						SCK_MAXIPADDRESSLENGTH + SCK_MAXHOSTNAMELENGTH];
					unsigned long							ulNICsNumber;

					cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. itItemType		=
						::StreamingIDL:: ENUMERATIVE;

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues). length (0);

					for (it = _vIPAddresses. begin (), ulNICsNumber = 0;
						it != _vIPAddresses. end ();
						++it, ulNICsNumber++)
					{
						iaIPAddress				= *it;

						if (!strcmp (iaIPAddress. pHostName, ""))
							sprintf (pIPAddressLabel, "%s",
							iaIPAddress. pIPAddress);
						else
							sprintf (pIPAddressLabel, "%s (%s)",
								iaIPAddress. pIPAddress,
								iaIPAddress. pHostName);

						(cilLocalConfigurationItemsWithInfoList [
							cilLocalConfigurationItemsWithInfoList.length () -
							lItemsNumber + lItemIndex]. pValues). length (
							ulNICsNumber + 1);

						(cilLocalConfigurationItemsWithInfoList [
							cilLocalConfigurationItemsWithInfoList.length () -
							lItemsNumber + lItemIndex]. pValues) [
							ulNICsNumber]	=
							CORBA:: string_dup (pIPAddressLabel);
					}

					cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pSelectionMode			=
						CORBA:: string_dup ("SINGLE");
				}
				else if (
					(!strcmp (pSectionName, "Cache") &&
					!strcmp (pItemName, "UseMP4ConsistencyCheck")) ||
					(!strcmp (pSectionName, "Authorization") &&
					!strcmp (pItemName, "Activated")) ||
					(!strcmp (pSectionName, "Commit") &&
					!strcmp (pItemName, "Activated")) ||
					(!strcmp (pSectionName, "SystemLogs") &&
					!strcmp (pItemName, "CompressedTraceFile")) ||
					(!strcmp (pSectionName, "SystemLogs") &&
					!strcmp (pItemName, "TraceOnTTY")) ||
					(!strcmp (pSectionName, "SubscriberLogs") &&
					!strcmp (pItemName, "CompressedTraceFile")) ||
					(!strcmp (pSectionName, "SubscriberLogs") &&
					!strcmp (pItemName, "TraceOnTTY")) ||
					(!strcmp (pSectionName, "SubscriberLogs") &&
					!strcmp (pItemName, "FlushTraceAfterEachRequest")) ||
					(!strcmp (pSectionName, "System") &&
					!strcmp (pItemName, "UseOfHintingTrackIfExist")) ||
					(!strcmp (pSectionName, "System") &&
					!strcmp (pItemName, "BuildOfHintingTrackIfNotExist"))
					)
				{
					cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. itItemType				=
						::StreamingIDL:: ENUMERATIVE;

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues). length (2);

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [0]		=
						CORBA:: string_dup ("false");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [1]		=
						CORBA:: string_dup ("true");

					cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pSelectionMode		=
						CORBA:: string_dup ("SINGLE");
				}
				else if (
					(!strcmp (pSectionName, "SystemLogs") &&
					!strcmp (pItemName, "TraceLevel")) ||
					(!strcmp (pSectionName, "SubscriberLogs") &&
					!strcmp (pItemName, "TraceLevel"))
					)
				{
					cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. itItemType			=
						::StreamingIDL:: ENUMERATIVE;

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues). length (11);

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [0]		=
						CORBA:: string_dup ("LDBG1");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [1]		=
						CORBA:: string_dup ("LDBG2");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [2]		=
						CORBA:: string_dup ("LDBG3");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [3]		=
						CORBA:: string_dup ("LDBG4");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [4]		=
						CORBA:: string_dup ("LDBG5");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [5]		=
						CORBA:: string_dup ("LDBG6");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [6]		=
						CORBA:: string_dup ("LINFO");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [7]		=
						CORBA:: string_dup ("LMESG");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [8]		=
						CORBA:: string_dup ("LWNRG");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [9]		=
						CORBA:: string_dup ("LERRR");

					(cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pValues) [10]		=
						CORBA:: string_dup ("LFTAL");

					cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. pSelectionMode		=
						CORBA:: string_dup ("SINGLE");
				}
				else if (
					(!strcmp (pSectionName, "StreamingServer") &&
					!strcmp (pItemName, "ContentRootPath")) ||
					(!strcmp (pSectionName, "Authorization") &&
					!strcmp (pItemName, "Servlet")) ||
					(!strcmp (pSectionName, "Authorization") &&
					!strcmp (pItemName, "WebServerIPAddress")) ||
					(!strcmp (pSectionName, "Commit") &&
					!strcmp (pItemName, "Servlet")) ||
					(!strcmp (pSectionName, "Commit") &&
					!strcmp (pItemName, "WebServerIPAddress")) ||
					(!strcmp (pSectionName, "SystemLogs") &&
					!strcmp (pItemName, "BaseTraceFileName")) ||
					(!strcmp (pSectionName, "SubscriberLogs") &&
					!strcmp (pItemName, "BaseTraceFileName")) ||
					(!strcmp (pSectionName, "SubscriberLogs") &&
					!strcmp (pItemName, "RequestLogFormat"))
					)
				{
					cilLocalConfigurationItemsWithInfoList [
						cilLocalConfigurationItemsWithInfoList.length () -
						lItemsNumber + lItemIndex]. itItemType		=
						::StreamingIDL:: TEXT;
				}
				else
				{
				}

				if (ciCfgItem. finish () != errNoError)
				{
					Error err = ConfigurationErrors (__FILE__, __LINE__,
						CFG_CONFIGURATIONITEM_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					return 11;
					// throw ::StreamingIDL:: StreamingExc (
					//	(const char *) err);
				}
			}

			if (csCfgSection. finish () != errNoError)
			{
				Error err = ConfigurationErrors (__FILE__, __LINE__,
					CFG_CONFIGURATIONSECTION_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				return 12;
				// throw ::StreamingIDL:: StreamingExc ((const char *) err);
			}
		}

		cilConfigurationItemsWithInfoList			= new 
			::StreamingIDL:: ConfigurationItemsWithInfoList (
			cilLocalConfigurationItemsWithInfoList);


		return 0;
	}


	CORBA:: Long StreamingServer:: getHostName (
		CORBA:: String_out pHostName)

	{

		pHostName				= CORBA:: string_dup (_pHostName);


		return 0;
	}


	CORBA:: Long StreamingServer:: getContents (
		const char *pDirectory,
		::StreamingIDL:: StringsList_out lsFileNames,
		::StreamingIDL:: StringsList_out lsDirectories)

	{

		::StreamingIDL:: StringsList		lsLocalFileNames (SS_MAXFILES);
		::StreamingIDL:: StringsList		lsLocalDirectories (
			SS_MAXDIRECTORIES);
		FileIO:: Directory_t				dDirectory;
		Error_t								errReadDirectory;
		Buffer_t							bDirectoryEntry;
		Boolean_t							bIsDirectory;
		Buffer_t							bDirectory;
		// Buffer_t							bDirectoryEntry;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_GETCONTENTS,
				1, pDirectory);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		lsLocalFileNames. length (0);
		lsLocalDirectories. length (0);

		if (bDirectory. init (_pContentRootPath) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. append ("/") != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. append (pDirectory) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 3;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectoryEntry. init () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 4;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (FileIO:: openDirectory ((const char *) bDirectory,
			&dDirectory) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_OPENDIRECTORY_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectoryEntry. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 5;
			// throw ::StreamingIDL:: StreamingExc (
			//	(const char *) err);
		}

		while ((errReadDirectory = FileIO:: readDirectory (&dDirectory,
			&bDirectoryEntry, &bIsDirectory)) == errNoError)
		{
			if (bIsDirectory)
			{
				if (lsLocalDirectories. length () + 1 > SS_MAXDIRECTORIES)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_LISTTOOLONG);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (FileIO:: closeDirectory (&dDirectory) != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_FILEIO_CLOSEDIRECTORY_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bDirectoryEntry. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bDirectory. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 6;
					// throw ::StreamingIDL:: StreamingExc (
					//	(const char *) err);
				}

				lsLocalDirectories. length (lsLocalDirectories. length () + 1);
				lsLocalDirectories [lsLocalDirectories. length () - 1]		=
					CORBA:: string_dup ((const char *) bDirectoryEntry);
			}
			else
			{
				if (lsLocalFileNames. length () + 1 > SS_MAXFILES)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_STREAMINGSERVER_LISTTOOLONG);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (FileIO:: closeDirectory (&dDirectory) != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_FILEIO_CLOSEDIRECTORY_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bDirectoryEntry. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bDirectory. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 7;
					// throw ::StreamingIDL:: StreamingExc (
					//	(const char *) err);
				}

				lsLocalFileNames. length (lsLocalFileNames. length () + 1);
				lsLocalFileNames [lsLocalFileNames. length () - 1]		=
					CORBA:: string_dup ((const char *) bDirectoryEntry);
			}
		}

		if ((long) errReadDirectory != TOOLS_FILEIO_DIRECTORYFILESFINISHED)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_READDIRECTORY_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (FileIO:: closeDirectory (&dDirectory) != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_FILEIO_CLOSEDIRECTORY_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bDirectoryEntry. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 8;
			// throw ::StreamingIDL:: StreamingExc (
			//	(const char *) err);
		}

		if (FileIO:: closeDirectory (&dDirectory) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_CLOSEDIRECTORY_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectoryEntry. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 9;
			// throw ::StreamingIDL:: StreamingExc (
			//	(const char *) err);
		}

		if (bDirectoryEntry. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 10;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 11;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		lsDirectories		= new ::StreamingIDL:: StringsList (
			lsLocalDirectories);
		lsFileNames			= new ::StreamingIDL:: StringsList (
			lsLocalFileNames);


		return 0;
	}


	CORBA:: Long StreamingServer:: addDirectory (
		const char *pDirectoryName)

	{

		Buffer_t							bDirectory;
		int									iMode;
		Error_t								errCreateDirectory;

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_ADDDIRECTORY,
				1, pDirectoryName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (bDirectory. init (_pContentRootPath) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. append ("/") != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. append (pDirectoryName) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 3;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_DIRECTORYTOCREATE,
				1, (const char *) bDirectory);
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		#ifdef WIN32
			iMode		= 0;
		#else
			iMode		= S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;
		#endif

		if ((errCreateDirectory = FileIO:: createDirectory (
			(const char *) bDirectory, iMode)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errCreateDirectory, __FILE__, __LINE__);

			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_CREATEDIRECTORY_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 4;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 5;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: deleteDirectory (
		const char *pDirectoryName)

	{

		Buffer_t							bDirectory;
		Error_t								errRemoveDirectory;

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_DELETEDIRECTORY,
				1, pDirectoryName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (bDirectory. init (_pContentRootPath) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. append ("/") != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. append (pDirectoryName) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 3;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_DIRECTORYTODELETE,
				1, (const char *) bDirectory);
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		if ((errRemoveDirectory = FileIO:: removeDirectory (
			(const char *) bDirectory)) != errNoError)
		{
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) errRemoveDirectory, __FILE__, __LINE__);

			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_REMOVEDIRECTORY_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDirectory. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 4;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDirectory. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 5;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: addContent (
		const char *pContentName, const ::StreamingIDL:: BytesList &
		blContent)

	{

		int							iFileDescriptor;
		unsigned char				*pucContent;
		unsigned long				ulContentLength;
		unsigned long				ulContentIndex;
		Buffer_t					bContentPathName;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_ADDCONTENT,
				1, pContentName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (bContentPathName. init (_pContentRootPath) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. append ("/") != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. append (pContentName) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 3;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		ulContentLength				= blContent. length ();

		if ((pucContent = new unsigned char [ulContentLength]) ==
			(unsigned char *) NULL)
		{
			Error err = StreamingServerErrors (__FILE__, __LINE__,
				SS_NEW_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 4;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		for (ulContentIndex = 0; ulContentIndex < ulContentLength;
			ulContentIndex++)
			pucContent [ulContentIndex]			= blContent [ulContentIndex];

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CONTENTTOCREATE,
				1, (const char *) bContentPathName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		#ifdef WIN32
			if (FileIO:: open ((const char *) bContentPathName,
				O_WRONLY | O_TRUNC | O_CREAT,
				_S_IREAD | _S_IWRITE, &iFileDescriptor) !=
				errNoError)
		#else
			if (FileIO:: open ((const char *) bContentPathName,
				O_WRONLY | O_TRUNC | O_CREAT,
				S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
				&iFileDescriptor) != errNoError)
		#endif
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_OPEN_FAILED,
				1, (const char *) bContentPathName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			delete [] pucContent;

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 5;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (FileIO:: writeBytes (iFileDescriptor,
			pucContent, ulContentLength) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_WRITEBYTES_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (FileIO:: close (iFileDescriptor) != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_FILEIO_CLOSE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			delete [] pucContent;

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 6;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (FileIO:: close (iFileDescriptor) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_CLOSE_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			delete [] pucContent;

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 7;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		delete [] pucContent;

		if (bContentPathName. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 8;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: deleteContent (
		const char *pContentName)

	{

		Buffer_t					bContentPathName;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_DELETECONTENT,
				1, pContentName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (bContentPathName. init (_pContentRootPath) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. append ("/") != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. append (pContentName) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 3;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CONTENTTODELETE,
				1, (const char *) bContentPathName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (FileIO:: remove ((const char *) bContentPathName) !=
			errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_FILEIO_REMOVE_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 4;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 5;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: dumpContent (
		const char *pContentName, CORBA:: String_out pDump)

	{

		Buffer_t					bContentPathName;
		MP4File_p					pmp4File;
		Boolean_t					bIsMP4FileInCache;
		Buffer_t					bDump;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_DUMPCONTENT,
				1, pContentName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (bContentPathName. init (_pContentRootPath) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. append ("/") != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. append (pContentName) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 3;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bDump. init ("", -1, 100000) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 4;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CONTENTTODUMP,
				1, (const char *) bContentPathName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (_mp4fMP4FileFactory. getMP4File (
			(const char *) bContentPathName,
			false, &pmp4File, false,
			_ulFileCacheSizeInBytes, _sStandard,
			&bIsMP4FileInCache) != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDump. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 5;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bIsMP4FileInCache)
		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_RTSPSESSION_MP4FILEINCACHE,
				2, (const char *) bContentPathName, "true");
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}
		else
		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_RTSPSESSION_MP4FILEINCACHE,
				2, (const char *) bContentPathName, "false");
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (pmp4File -> getDump (&bDump) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (_mp4fMP4FileFactory. releaseMP4File (
				(const char *) bContentPathName) != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bDump. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 6;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (_mp4fMP4FileFactory. releaseMP4File (
			(const char *) bContentPathName) != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bDump. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 7;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		pDump				= CORBA:: string_dup ((const char *) bDump);

		if (bDump. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 8;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}

		if (bContentPathName. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 9;
			// throw ::StreamingIDL:: StreamingExc ((const char *) err);
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: getTracksInfo (
		const char *pContentName, CORBA:: String_out pTracksInfo)

	{

		Buffer_t						bContentPathName;
		MP4File_p						pmp4File;
		Boolean_t						bIsMP4FileInCache;
		Buffer_t						bTracksInfo;
		char							pCodecName [MP4F_MAXCODECUSEDLENGTH];
		std:: vector<MP4TrackInfo_p>	*pvMP4TracksInfo;
		unsigned long					ulTrackIdentifier;
		char						pHandlerType [MP4F_MAXHANDLERTYPELENGTH];
		MP4Atom:: MP4Codec_t			cCodec;
		char							pTrackName [MP4F_MAXTRACKNAMELENGTH];

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_GETTRACKSINFO,
				1, pContentName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (bContentPathName. init (_pContentRootPath) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
		}

		if (bContentPathName. append ("/") != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
		}

		if (bContentPathName. append (pContentName) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_APPEND_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 3;
		}

		if (bTracksInfo. init ("", -1, 10000) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 4;
		}

		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CONTENTTOHAVETRACKSINFO,
				1, (const char *) bContentPathName);
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (_mp4fMP4FileFactory. getMP4File (
			(const char *) bContentPathName,
			false, &pmp4File, false,
			_ulFileCacheSizeInBytes, _sStandard,
			&bIsMP4FileInCache) != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bTracksInfo. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 5;
		}

		if (bIsMP4FileInCache)
		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_RTSPSESSION_MP4FILEINCACHE,
				2, (const char *) bContentPathName, "true");
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}
		else
		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_RTSPSESSION_MP4FILEINCACHE,
				2, (const char *) bContentPathName, "false");
			_ptSystemTracer -> trace (Tracer:: TRACER_LINFO, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (pmp4File -> getTracksInfo (&pvMP4TracksInfo) != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILE_GETTRACKSINFO_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (_mp4fMP4FileFactory. releaseMP4File (
				(const char *) bContentPathName) != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bTracksInfo. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 6;
		}

		if (bTracksInfo. setBuffer (
			"\tTrack Identifier\t\tHandler Type\t\tCodec used\t\tTrack Name\n"
			) != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_SETBUFFER_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (_mp4fMP4FileFactory. releaseMP4File (
				(const char *) bContentPathName) != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bTracksInfo. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 7;
		}

		if (pvMP4TracksInfo -> size () > 0)
		{
			std:: vector<MP4TrackInfo_p>:: const_iterator	it;
			MP4TrackInfo_p						pmtiMP4TrackInfo;


			for (it = pvMP4TracksInfo -> begin ();
				it != pvMP4TracksInfo -> end (); ++it)
			{
				pmtiMP4TrackInfo				= *it;

				if (bTracksInfo. append ("\t") != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 8;
				}

				if (pmtiMP4TrackInfo -> getTrackIdentifier (
					&ulTrackIdentifier) != errNoError)
				{
					Error err = MP4FileErrors (__FILE__, __LINE__,
						MP4F_MP4TRACKINFO_GETTRACKIDENTIFIER_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 9;
				}

				if (bTracksInfo. append (
					ulTrackIdentifier) != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 10;
				}

				if (bTracksInfo. append ("\t\t\t\t") != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 11;
				}

				if (pmtiMP4TrackInfo -> getHandlerType (
					pHandlerType) != errNoError)
				{
					Error err = MP4FileErrors (__FILE__, __LINE__,
						MP4F_MP4TRACKINFO_GETHANDLERTYPE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 12;
				}

				if (bTracksInfo. append (pHandlerType) !=
					errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 13;
				}

				if (bTracksInfo. append ("\t\t\t") != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 14;
				}

				if (pmtiMP4TrackInfo -> getCodec (
					&cCodec) != errNoError)
				{
					Error err = MP4FileErrors (__FILE__, __LINE__,
						MP4F_MP4TRACKINFO_GETCODEC_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 15;
				}

				if (MP4Utility:: getCodecName (cCodec,
					pCodecName) != errNoError)
				{
					Error err = MP4FileErrors (__FILE__, __LINE__,
						MP4F_MP4UTILITY_GETCODECNAME_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 16;
				}

				if (bTracksInfo. append (pCodecName) != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 17;
				}

				if (bTracksInfo. append ("\t\t\t") != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 18;
				}

				if (pmtiMP4TrackInfo -> getTrackName (
					pTrackName) != errNoError)
				{
					Error err = MP4FileErrors (__FILE__, __LINE__,
						MP4F_MP4TRACKINFO_GETTRACKNAME_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 19;
				}

				if (bTracksInfo. append (pTrackName) !=
					errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 20;
				}

				if (bTracksInfo. append ("\n") != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_APPEND_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (_mp4fMP4FileFactory. releaseMP4File (
						(const char *) bContentPathName) != errNoError)
					{
						Error err = MP4FileErrors (__FILE__, __LINE__,
							MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bTracksInfo. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bContentPathName. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 21;
				}
			}
		}

		if (_mp4fMP4FileFactory. releaseMP4File (
			(const char *) bContentPathName) != errNoError)
		{
			Error err = MP4FileErrors (__FILE__, __LINE__,
				MP4F_MP4FILEFACTORY_GETMP4FILE_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bTracksInfo. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 22;
		}

		pTracksInfo			= CORBA:: string_dup ((const char *) bTracksInfo);

		if (bTracksInfo. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bContentPathName. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 23;
		}

		if (bContentPathName. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 24;
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: getServerConnectedUsers (
		::StreamingIDL:: ServerConnectedUsersList_out
		scuServerConnectedUsersList)

	{

		::StreamingIDL:: ServerConnectedUsersList
			scuLocalServerConnectedUsersList (_ulMaxRTSPServerSessions);

		unsigned long			ulRTSPSessionIdentifier;
		char					pClientIPAddress [SCK_MAXIPADDRESSLENGTH];
		Buffer_t				bURLWithoutParameters;
		Buffer_t				bURLParameters;
		MP4Atom:: Standard_t	sStandard;
		Boolean_t				bIsLive;
		double					dMovieDuration;
		MP4Atom:: MP4Codec_t	cVideoCodec;
		char					pVideoCodec [MP4F_MAXCODECUSEDLENGTH];
		unsigned long			ulVideoPacketsNumberSent;
		unsigned long			ulVideoPacketsNumberLost;
		unsigned long			ulVideoAverageBitRate;
		unsigned long			ulVideoRTCPPacketsNumberReceived;
		unsigned long			ulVideoJitter;
		MP4Atom:: MP4Codec_t	cAudioCodec;
		char					pAudioCodec [MP4F_MAXCODECUSEDLENGTH];
		unsigned long			ulAudioPacketsNumberSent;
		unsigned long			ulAudioPacketsNumberLost;
		unsigned long			ulAudioAverageBitRate;
		unsigned long			ulAudioRTCPPacketsNumberReceived;
		unsigned long			ulAudioJitter;
		#ifdef WIN32
			__int64					ullVideoBytesSent;
			__int64					ullAudioBytesSent;
			__int64					ullVideoRTCPBytesReceived;
			__int64					ullAudioRTCPBytesReceived;
			__int64					ullConnectedTimeInSeconds;
		#else
			unsigned long long		ullVideoBytesSent;
			unsigned long long		ullAudioBytesSent;
			unsigned long long		ullVideoRTCPBytesReceived;
			unsigned long long		ullAudioRTCPBytesReceived;
			unsigned long long		ullConnectedTimeInSeconds;
		#endif
		Error_t						errGetInfo;
		unsigned long				ulLengthList;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_GETSERVERCONNECTEDUSERS);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG5, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (bURLWithoutParameters. init () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 1;
		}

		if (bURLParameters. init () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_INIT_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bURLWithoutParameters. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 2;
		}

		scuLocalServerConnectedUsersList. length (0);

		for (ulRTSPSessionIdentifier = 0;
			ulRTSPSessionIdentifier < _ulMaxRTSPServerSessions;
			ulRTSPSessionIdentifier++)
		{
			if ((errGetInfo = (_prsRTSPSessions [
				ulRTSPSessionIdentifier]). getInfo (
				pClientIPAddress,
				&bURLWithoutParameters,
				&bURLParameters,
				&sStandard,
				&bIsLive,
				&dMovieDuration,
				&cVideoCodec,
				&ulVideoPacketsNumberSent,
				&ullVideoBytesSent,
				&ulVideoPacketsNumberLost,
				&ulVideoAverageBitRate,
				&ulVideoRTCPPacketsNumberReceived,
				&ullVideoRTCPBytesReceived,
				&ulVideoJitter,
				&cAudioCodec,
				&ulAudioPacketsNumberSent,
				&ullAudioBytesSent,
				&ulAudioPacketsNumberLost,
				&ulAudioAverageBitRate,
				&ulAudioRTCPPacketsNumberReceived,
				&ullAudioRTCPBytesReceived,
				&ulAudioJitter,
				&ullConnectedTimeInSeconds
				)) != errNoError)
			{
				if ((long) errGetInfo != SS_RTSPSESSION_WRONGSTATE)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_RTSPSESSION_GETINFO_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					if (bURLParameters. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					if (bURLWithoutParameters. finish () != errNoError)
					{
						Error err = ToolsErrors (__FILE__, __LINE__,
							TOOLS_BUFFER_FINISH_FAILED);
						_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
							(const char *) err, __FILE__, __LINE__);
					}

					return 3;
				}
				else
					continue;
			}

			ulLengthList		= scuLocalServerConnectedUsersList. length ();

			scuLocalServerConnectedUsersList. length (ulLengthList + 1);

			scuLocalServerConnectedUsersList [ulLengthList].
				pClientIPAddress				=
				CORBA:: string_dup (pClientIPAddress);

			scuLocalServerConnectedUsersList [ulLengthList].
				pURLWithoutParameters			=
				CORBA:: string_dup ((const char *) bURLWithoutParameters);

			scuLocalServerConnectedUsersList [ulLengthList].
				pURLParameters					=
				CORBA:: string_dup ((const char *) bURLParameters);

			if (sStandard == MP4Atom:: MP4F_3GPP)
			{
				scuLocalServerConnectedUsersList [ulLengthList].
					pStandardUsed					=
					CORBA:: string_dup ("3GPP");
			}
			else
			{
				scuLocalServerConnectedUsersList [ulLengthList].
					pStandardUsed					=
					CORBA:: string_dup ("ISMA");
			}

			scuLocalServerConnectedUsersList [ulLengthList].
				ulConnectionLive				= bIsLive ? 1 : 0;

			scuLocalServerConnectedUsersList [ulLengthList].
				dMovieDuration					= dMovieDuration;

			if (MP4Utility:: getCodecName (cVideoCodec,
				pVideoCodec) != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4UTILITY_GETCODECNAME_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				if (bURLParameters. finish () != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				if (bURLWithoutParameters. finish () != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				return 4;
			}

			scuLocalServerConnectedUsersList [ulLengthList].
				pVideoCodec						=
				CORBA:: string_dup (pVideoCodec);

			scuLocalServerConnectedUsersList [ulLengthList].
				ulVideoPacketsNumberSent		=
				ulVideoPacketsNumberSent;

			scuLocalServerConnectedUsersList [ulLengthList].
				ullVideoBytesSent				=
				ullVideoBytesSent;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulVideoPacketsNumberLost		=
				ulVideoPacketsNumberLost;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulVideoAverageBitRate			=
				ulVideoAverageBitRate;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulVideoRTCPPacketsNumberReceived		=
				ulVideoRTCPPacketsNumberReceived;

			scuLocalServerConnectedUsersList [ulLengthList].
				ullVideoRTCPBytesReceived		=
				ullVideoRTCPBytesReceived;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulVideoJitter					=
				ulVideoJitter;

			if (MP4Utility:: getCodecName (cAudioCodec,
				pAudioCodec) != errNoError)
			{
				Error err = MP4FileErrors (__FILE__, __LINE__,
					MP4F_MP4UTILITY_GETCODECNAME_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);

				if (bURLParameters. finish () != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				if (bURLWithoutParameters. finish () != errNoError)
				{
					Error err = ToolsErrors (__FILE__, __LINE__,
						TOOLS_BUFFER_FINISH_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);
				}

				return 5;
			}

			scuLocalServerConnectedUsersList [ulLengthList].
				pAudioCodec						=
				CORBA:: string_dup (pAudioCodec);

			scuLocalServerConnectedUsersList [ulLengthList].
				ulAudioPacketsNumberSent		=
				ulAudioPacketsNumberSent;

			scuLocalServerConnectedUsersList [ulLengthList].
				ullAudioBytesSent				=
				ullAudioBytesSent;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulAudioPacketsNumberLost		=
				ulAudioPacketsNumberLost;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulAudioAverageBitRate			=
				ulAudioAverageBitRate;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulAudioRTCPPacketsNumberReceived		=
				ulAudioRTCPPacketsNumberReceived;

			scuLocalServerConnectedUsersList [ulLengthList].
				ullAudioRTCPBytesReceived		=
				ullAudioRTCPBytesReceived;

			scuLocalServerConnectedUsersList [ulLengthList].
				ulAudioJitter					=
				ulAudioJitter;

			scuLocalServerConnectedUsersList [ulLengthList].
				ullConnectedTimeInSeconds		=
				ullConnectedTimeInSeconds;
		}

		scuServerConnectedUsersList			= new 
			::StreamingIDL:: ServerConnectedUsersList (
			scuLocalServerConnectedUsersList);

		if (bURLParameters. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			if (bURLWithoutParameters. finish () != errNoError)
			{
				Error err = ToolsErrors (__FILE__, __LINE__,
					TOOLS_BUFFER_FINISH_FAILED);
				_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
					(const char *) err, __FILE__, __LINE__);
			}

			return 6;
		}

		if (bURLWithoutParameters. finish () != errNoError)
		{
			Error err = ToolsErrors (__FILE__, __LINE__,
				TOOLS_BUFFER_FINISH_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 7;
		}


		return 0;
	}


	CORBA:: Long StreamingServer:: getServerInfo (
		::StreamingIDL:: ServerInfo_out siServerInfo)

	{

		::StreamingIDL:: ServerInfo				siLocalInfo;
		::StreamingIDL:: ServerInfo_var			siLocalServerInfo;

		Boolean_t				bIsStarted;
		GetCpuUsage_t			gcuGetCpuUsage;
		unsigned long			ulRTSPSessionIdentifier;
		unsigned long			ulFreeRTSPSessions;
		Error_t					errGetInfo;
		unsigned long			ulAverageBandWidthUsage;


		{
			Message msg = StreamingServerMessages (__FILE__, __LINE__,
				SS_STREAMINGSERVER_CORBA_GETSERVERINFO);
			_ptSystemTracer -> trace (Tracer:: TRACER_LDBG6, (const char *) msg,
				__FILE__, __LINE__);
		}

		if (_cssCheckServerSocketTimes. isStarted (&bIsStarted) != errNoError)
		{
			Error err = SchedulerErrors (__FILE__, __LINE__,
				SCH_TIMES_START_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);
		
			return 1;
		}

		if (bIsStarted)
			siLocalInfo. ssStatus				= ::StreamingIDL:: ACTIVE;
		else
			siLocalInfo. ssStatus				= ::StreamingIDL:: INACTIVE;

		siLocalInfo. ulUpTimeInMinutes	=
			(time (NULL) - _tServerStartTime) / 60;
		siLocalInfo. pServerVersion		= CORBA:: string_dup (".....");
		siLocalInfo. ulCPUUsage			= gcuGetCpuUsage. getCpuUsage ();
		siLocalInfo. ulMemoryUsage		= 0;	// da calcolare

		if (_mtFreeRTSPSessions. lock () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_LOCK_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 2;
		}

		ulFreeRTSPSessions		= _vFreeRTSPSessions. size ();

		if (_mtFreeRTSPSessions. unLock () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_UNLOCK_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 3;
		}

		siLocalInfo. ulPlayersNumberConnected	=
			_ulMaxRTSPServerSessions - ulFreeRTSPSessions;

		siLocalInfo. ulBandWidthUsageInbps		= 0;

		for (ulRTSPSessionIdentifier = 0;
			ulRTSPSessionIdentifier < _ulMaxRTSPServerSessions;
			ulRTSPSessionIdentifier++)
		{
			if ((errGetInfo = (_prsRTSPSessions [
				ulRTSPSessionIdentifier]). getAverageBandWidthUsage (
				&ulAverageBandWidthUsage)) != errNoError)
			{
				if ((long) errGetInfo != SS_RTSPSESSION_WRONGSTATE)
				{
					Error err = StreamingServerErrors (__FILE__, __LINE__,
						SS_RTSPSESSION_GETAVERAGEBANDWIDTHUSAGE_FAILED);
					_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
						(const char *) err, __FILE__, __LINE__);

					return 4;
				}
				else
					continue;
			}

			siLocalInfo. ulBandWidthUsageInbps		+= ulAverageBandWidthUsage;
		}

		if (_mtStreamingServerStatistics. lock () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_LOCK_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 5;
		}

		siLocalInfo. ullTotalBytesServed		= _ullTotalBytesServed;
		siLocalInfo. ullTotalLostPacketsNumber	= _ullTotalLostPacketsNumber;
		siLocalInfo. ullTotalSentPacketsNumber	= _ullTotalSentPacketsNumber;

		if (_mtStreamingServerStatistics. unLock () != errNoError)
		{
			Error err = PThreadErrors (__FILE__, __LINE__,
				THREADLIB_PMUTEX_UNLOCK_FAILED);
			_ptSystemTracer -> trace (Tracer:: TRACER_LERRR,
				(const char *) err, __FILE__, __LINE__);

			return 6;
		}

		siServerInfo			= new ::StreamingIDL:: ServerInfo (
			siLocalInfo);


		return 0;
	}
#endif
